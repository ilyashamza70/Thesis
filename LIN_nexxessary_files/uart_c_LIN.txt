/**
  UART1 Generated Driver File 

  @Company
    Microchip Technology Inc.

  @File Name
    uart1.c

  @Summary
    This is the generated source file for the UART1 driver using PIC24 / dsPIC33 / PIC32MM MCUs

  @Description
    This source file provides APIs for driver for UART1. 
    Generation Information : 
        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.167.0
        Device            :  dsPIC33CK256MP508
    The generated drivers are tested against the following:
        Compiler          :  XC16 v1.50
        MPLAB             :  MPLAB X v5.35
*/

/*
    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
    software and any derivatives exclusively with Microchip products.

    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.

    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.

    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
    TERMS.
*/


#include "uart1.h"
#include "interrupt_vector_table.h"
#include "firmware_identification.h"
#include "lin_structs.h"
#include "lin_pdu_protocol.h"
#include "lin.h"
#include <string.h>


// Clock in ingresso alla periferica UART
#if (CPU_CLOCK_ID == CPU_CLOCK_100_Mhz)
#define LIN_UART_CLOCK_SOURCE__Hz       (100000000UL)     // 100 MHz (FOSC/2 = FP = 100 MHz)
#elif (CPU_CLOCK_ID == CPU_CLOCK_70_Mhz)
#define LIN_UART_CLOCK_SOURCE__Hz       (70000000UL)      // 70 MHz (FOSC/2 = FP = 70 MHz)
#endif

// Baud rate disponibili [bit/s]
#define UART_BAUD_RATE__2400bit_s       (2400UL)
#define UART_BAUD_RATE__9600bit_s       (9600UL)
#define UART_BAUD_RATE__10400bit_s      (10400UL)
#define UART_BAUD_RATE__19200bit_s      (19200UL)
// Baud rate LIN [bit/s]
#define LIN_BAUD_RATE__bit_s            UART_BAUD_RATE__19200bit_s

/* We add one extra byte than requested so that we don't have to have a separate
 * bit to determine the difference between buffer full and buffer empty, but
 * still be able to hold the amount of data requested by the user.  Empty is
 * when head == tail.  So full will result in head/tail being off by one due to
 * the extra byte.
 */
#define UART1_CONFIG_RX_BYTEQ_LENGTH    (8+1)  // per contenere il PID byte (Protected ID) + 8 bytes di dato


// stati possibili della LIN
typedef enum LIN_STATE_en {
    LIN_ST__RX_PID,
    LIN_ST__RX_DATA,
} t_LIN_STATE_en;


t_LIN_STATE_en lin_state;


// buffer circolare di ricezione
uint8_t rxQueue[UART1_CONFIG_RX_BYTEQ_LENGTH];

uint8_t * volatile rxHead;
uint8_t * volatile rxTail;
bool volatile rxOverflowed;

// Ultrimo LIN-ID ricevuto (PID senza i 2 bit piu' significativi di parita')
uint8_t lin_ID = 0;

// indice del message object LIN di cui sto ricevendo o trasmettendo il payload
uint8_t lin_msg_obj_idx;

bool lin_new_msg = false;


/**
  Section: Driver Interface
*/
void UART1_Initialize(void)
{
    // Data Bits = 8; Parity = None; Stop Bits = 1 Stop bit sent, 1 checked at RX;

    // UART1 CONFIGURATION REGISTER

    /* UARTEN = 0    : UART state machine, FIFO Buffer Pointers and counters are reset; registers are readable and writable (UART Enable bit)
     * USIDL  = 0    : Continues module operation in Idle mode
     * WAKE   = 0    : RX pin is not monitored on rising edge detected (Auto-Baud Detection disabled)
     *                 (datasheet: Set the ABAUD bit. If a Break precedes the Sync byte, also set the WAKE bit
     *                 to configure the UART to perform the auto-baud procedure on the Sync and not the Break.
     *                 The RXBKIF flag (UxSTA<2>) will not be set).
     * RXBIMD = 0    : RXBKIF flag when the Break makes a low-to-high transition after being low for at least 23/11 bit periods
     * BRKOVR = 0    : TX line is driven by the shifter (Send Break Software Override bit)
     * UTXBRK = 0    : Sync Break transmission is disabled or has completed
     * BRGH   = 1    : High Speed: Baud rate is baudclk/4
     * ABAUD  = 0    : Disables baud rate measurement on the next character
     * UTXEN  = 0    : Transmit disabled  all transmit counters, pointers and state machines are reset; TX buffer is not flushed, status bits are not reset (UART Transmit Enable bit)
     * URXEN  = 0    : Receive disabled  all receive counters, pointers and state machines are reset; RX buffer is not flushed, status bits are not reset (UART Receive Enable bit)
     * MOD    = 1011 : LIN Slave only
     */
    U1MODE = 0x008B;

    /* SLPEN    = 0  : UART BRG clock is turned off during Sleep
     * ACTIVE   = 0  : UART clock request is not active (user can update the UxMODE/UxMODEH registers)
     * BCLKMOD  = 0  : Uses legacy divide-by-x counter for baud clock generation (x = 4 or 16 depending on the BRGH bit), Baud Clock Generation Mode Select bit
     * BCLKSEL  = 00 : FOSC/2 = FP (peripheral clock)
     * HALFDPLX = 0  : Full-Duplex mode: UxTX is driven as an output at all times when both UARTEN and UTXEN are set
     * RUNOVF   = 1  : Run During Overflow Condition Mode
     *                 --> When an Overflow Error (OERR) condition is detected, the RX shifter continues to run so as to
     *                     remain synchronized with incoming RX data; data are not transferred to UxRXREG when it is full
     *                     (i.e., no UxRXREG data are overwritten)
     * URXINV   = 0  : Input is not inverted; Idle state is high (UART Receive Polarity bit)
     * STSEL    = 00 : 1 Stop bit sent, 1 checked at receive ( Number of Stop Bits Selection bits)
     * C0EN     = 1  : Checksum Enhanced, il checksum e' calcolato includendo anche il byte del PID (PID + data bytes)
     *                 NOTA: se settato a 0 Checksum Classic, checksum calcolato solo sui data bytes.
     * UTXINV   = 0  : Output data are not inverted; TX output is high in Idle state (UART Transmit Polarity bit)
     * FLO      = 00 : Flow control off (only valid when MOD[3:0] = 0xxx)
     */
    U1MODEH = 0x0088;


    // UART1 STATUS REGISTER

    /* TXMTIE = 0 : Transmit Shifter Empty Interrupt disabled
     * PERIE  = 0 : Parity Error Interrupt disabled
     * ABDOVE = 0 : Auto-Baud Rate Acquisition Interrupt disabled
     * CERIE  = 0 : Checksum Error Interrupt disabled
     * FERIE  = 0 : Framing Error Interrupt disabled
     * RXBKIE = 0 : Receive Break Interrupt disabled
     * OERIE  = 0 : Receive Buffer Overflow Interrupt disabled
     * TXCIE  = 0 : Transmit Collision Interrupt disabled
     * TRMT   = 0 : Transmit Shifter Empty Interrupt Flag bit (read-only), 1 = Transmit Shift Register (TSR) is empty
     * PERR   = 0 : Parity Error Interrupt FLAG bit, 1 = Parity error detected
     * ABDOVF = 0 : Auto-Baud Rate Acquisition Interrupt FLAG bit (must be cleared by software)
     *              NOTA: va a 1 quando avviene un overflow del contatore BRG che calcola l'Auto Baud Rate
     *              (per eseguire il clear di questo flag eseguire : ABAUD = 0; ABDOVF = 0; ABAUD = 1;)
     * CERIF  = 0 : Checksum Error Interrupt FLAG bit (must be cleared by software), 1 = Checksum error
     * FERR   = 0 : Framing Error Interrupt FLAG bit
     * RXBKIF = 0 : Receive Break Interrupt FLAG bit (must be cleared by software), 1 = A Break was received
     * OERR   = 0 : Receive Buffer Overflow Interrupt FLAG bit (must be cleared by software), 1 = Receive buffer has overflowed
     * TXCIF  = 0 : Transmit Collision Interrupt FLAG bit (must be cleared by software), 1 = Transmitted word is not equal to the received word
     */
    U1STA = 0x0000;

    /* UTXISEL = 000 : Sets transmit interrupt when there are eight empty slots in the buffer; TX buffer is empty (UART Transmit Interrupt Select bits)
     * URXISEL = 000 : Triggers receive interrupt when there is one byte or more in the buffer (UART Receive Interrupt Select bits)
     *                 NOTA: The receive watermark interrupt is not set if PERR or FERR is set and the corresponding IE bit is set
     * TXWRE   = 0   : TX Write Transmit Error Status bit
     *                 0 = No error - 1 = A new byte was written when the buffer was full or when P2[8:0] = 0 (must be cleared by software)
     * STPMD   = 0   : Triggers RXIF in the middle of the first (or second, depending on the STSEL[1:0] setting) Stop bit (Stop Bit Detection Mode bit)
     * UTXBE   = 1   : Transmit buffer is empty; writing 1 when UTXEN = 0 will reset the TX FIFO Pointers and counters
     * UTXBF   = 0   : Transmit buffer is not full (UART TX Buffer Full Status bit)
     * RIDLE   = 0   : UART RX line is receiving something (Receive Idle bit), 1 = UART RX line is in the Idle state
     * XON     = 0   : UART in XON Mode bit, Only valid when FLO[1:0] control bits are set to XON/XOFF mode.
     * URXBE   = 1   : UART RX Buffer Empty Status bit,
     *                 0 = Receive buffer is not empty - 1 = Receive buffer is empty (writing 1 when URXEN = 0 will reset the RX FIFO Pointers and counters)
     * URXBF   = 0   : UART RX Buffer Full Status bit
     *                 0 = Receive buffer is not full - 1 = Receive buffer is full
     */
    U1STAH = 0x0022;


    // UART1 BAUD RATE REGISTER

    // Baud Rate Divisor bits (diviso 4 quando BRGH = 1, diviso 16 quando BRGH = 0)
    U1BRG = (uint16_t)(((uint32_t)LIN_UART_CLOCK_SOURCE__Hz / (4UL * LIN_BAUD_RATE__bit_s)) - 1);
    // BRG 0; 
    U1BRGH = 0x0000;


    // PID to transmit (bits[5:0]), only in LIN Master TX (non usato, periferica in LIN Slave)
    U1P1 = 0x0000;

    // Number of bytes to transmit (bits[7:0]), only in LIN Slave TX
    U1P2 = 0x0000;

    // Number of bytes to receive (bits[7:0]), only in LIN Slave RX
    U1P3 = 0x0000;

    // in LIN mode not used
    U1P3H = 0x0000;


    // LIN CHECKSUM DI TRASMISSIONE E RICEZIONE (calcolato in hardware dalla periferica e risultato del calcolo disponibile nei 2 registri sotto)

    // Transmit Checksum bits (calculated from TX bytes); C0EN defines if PID byte is included or not in checksum calculation
    U1TXCHK = 0x0000;
    // Receive Checksum bits (calculated from RX words); C0EN defines if PID byte is included or not in checksum calculation
    U1RXCHK = 0x0000;


    // UART1 SMART CARD CONFIGURATION REGISTER (not used in LIN mode)
    U1SCCON = 0x0000;

    // UART1 SMART CARD INTERRUPT REGISTER (not used in LIN mode)
    U1SCINT = 0x0000;

    // UART1 INTERRUPT REGISTER

    /* WUIF  = 0 : Wake-up Interrupt FLAG bit
     *             0 = WAKE is not enabled or WAKE is enabled, but no wake-up event has occurred
     *             1 = Sets when WAKE = 1 and RX makes a 1-to-0 transition; triggers event interrupt (must be cleared by software)
     * ABDIF = 0 : Auto-Baud Completed Interrupt Flag bit
     *             0 = ABAUD is not enabled or ABAUD is enabled but auto-baud has not completed
     *             1 = Sets when ABD sequence makes the final 1-to-0 transition; triggers event interrupt (must be cleared by software)
     * ABDIE = 0 : Auto-Baud Completed Interrupt Enable bit
     *             0 = ABDIF does not set an event interrupt
     *             1 = Allows ABDIF to set an event interrupt
     */
    U1INT = 0x0000;


    // clear buffer circolare di ricezione
    memset(rxQueue, 0U, UART1_CONFIG_RX_BYTEQ_LENGTH);

    // Sia la testa e sia la coda puntano al primo elemento dell'array rxQueue[]
    rxHead = rxQueue;
    rxTail = rxQueue;

    rxOverflowed = false;

    // inizialmente nell'interrupt di ricezione attendo un Protected ID
    lin_state = LIN_ST__RX_PID;

    // abilito interrupt di ricezione
    IFS0bits.U1RXIF = false;
    IEC0bits.U1RXIE = true;
    IPC2bits.U1RXIP = INTERRUPT_LEVEL_UART1_LIN;

    
    //Make sure to set LAT bit corresponding to TxPin as high before UART initialization (see: PIN_MANAGER_Initialize())
    U1MODEbits.UARTEN = 1;   // enabling UART ON bit
    U1MODEbits.UTXEN = 1;
    U1MODEbits.URXEN = 1;
}


void UART1_deinitialize(void)
{
    // disabilitazione della periferica LIN
    U1MODEbits.UARTEN = 0;
    U1MODEbits.UTXEN = 0;
    U1MODEbits.URXEN = 0;

    // disabilito interrupt di ricezione
    IEC0bits.U1RXIE = false;
    IFS0bits.U1RXIF = false;
}


/**
    Maintains the driver's transmitter state machine and implements its ISR
*/

/* Due cause per cui scatta questo interrupt di ricezione:
 * 1) ricezione del PID (Protected ID)
 * 2) ricezione di N data bytes, configurati nel registro U1P3 (watermark interrupt).
 */
//void __attribute__ ( ( interrupt, no_auto_psv ) ) _U1RXInterrupt( void )
void IRQ_U1RXInterrupt(void)
{

#if 0
    // 1. lettura dei dati ricevuti via LIN (PID oppure dati) e copia nel buffer circolare di ricezione
    // -------------------------------------------------------------------------
    while(!(U1STAHbits.URXBE == 1))
    {
        // scodo la FIFO di ricezione
        *rxTail = U1RXREG;

        // Will the increment not result in a wrap and not result in a pure collision?
        // This is most often condition so check first
        if ( ( rxTail    != (rxQueue + UART1_CONFIG_RX_BYTEQ_LENGTH-1)) &&
             ((rxTail+1) != rxHead) )
        {
            rxTail++;
        } 
        else if ( (rxTail == (rxQueue + UART1_CONFIG_RX_BYTEQ_LENGTH-1)) &&
                  (rxHead !=  rxQueue) )
        {
            // Pure wrap no collision
            rxTail = rxQueue;
        } 
        else // must be collision
        {
            rxOverflowed = true;
        }
    }


    // 2. verifica se ho ricevuto il PID o i dati
    // -------------------------------------------------------------------------
    switch (lin_state)
    {
    case LIN_ST__RX_PID:
        {
            // se ho ricevuto il segnale iniziale di SYNC brake
            if (U1STAbits.RXBKIF)
            {
                U1STAbits.RXBKIF = 0; // must be cleared by software

                // se c'e' un errore dei bit di parita' del PID (Protected ID)
                if (U1STAbits.PERR)
                {
                    // clear dell'errore e non faccio nient'altro (non considero i data byte e attendo un nuovo PID valido)
                    U1STAbits.PERR = 0;
                }
                else    // PID valido
                {
                    // lettura del ID dal buffer circolare di ricezione
                    if (UART1_IsRxReady())
                        lin_ID = (UART1_Read() & 0x3F);    // l'ID corrisponde ai 6 bit meno significativi del PID

                    // Ricerca se l'ID ricevuto corrisponde ad un message object LIN mappato
                    for (lin_msg_obj_idx = 0; lin_msg_obj_idx < LIN_MESSAGE_OBJ_TOTAL_NUMBER; lin_msg_obj_idx++)
                    {
                        // check se il message object LIN e' configurato
                        if (LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].config.valid)
                        {
                            if (LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].identifier == lin_ID)
                                break;  // ID message object LIN trovato!
                        }
                    }

                    if (lin_msg_obj_idx < LIN_MESSAGE_OBJ_TOTAL_NUMBER)
                    {
                        // message object LIN configurato come Slave transmission
                        if (LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].config.dir_0rx1tx)
                        {
                            // prima che lo slave trasmetta deve essergli arrivata una richiesta di trasmissione da
                            // parte del master, solo in questo caso, in un sistema multi-slave, questo slave risponderà
                            if (LIN_tx_is_request_pending())
                            {
                                // configuro quanti byte deve trasmettere lo slave per questo ID
                                U1P2 = LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].config.data_length;

                                // reset della fifo di trasmissione U1TXREG
                                U1STAHbits.UTXBE = 1;

                                // Carico la fifo di trasmissione con i byte del payload da trasmettere
                                for (i = 0; i < LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].config.data_length; i++)
                                {
                                    U1TXREG = LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].p_buffer->payload[i];
                                }
                                // Da qui si occupa l'hardware della periferica UART a trasmettere..

                                // alzo il flag che notifica l'avvenuta richiesta di trasmissione da parte del Master LIN
                                LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].p_buffer->flag_tx_rx_data_new = 1;
                                
                                // pulisco la richiesta di trasmissione
                                LIN_tx_clear_request();
                            }
                        }
                        else    // message object LIN configurato come Slave reception
                        {
                            // scrivo il numero di data bytes che mi aspetto di riceve per questo PID
                            U1P3 = LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].config.data_length;

                            // configuro quando far scattare l'interrupt di ricezione dopo N byte di dato ricevuti (in generale N - 1)
                            U1STAHbits.URXISEL = LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].config.data_length - 1;

                            // setto a zero il flag che va alto quando avro' ricevuto tutti i data byte per questo PID
                            LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].p_buffer->flag_tx_rx_data_new = 0;

                            lin_state = LIN_ST__RX_DATA;
                        }
                    }
                }
            }
        }
        break;

    case LIN_ST__RX_DATA:
        {
            // se c'e' stato un errore nel checksum dei dati
             if (U1STAbits.CERIF)
            {
                U1STAbits.CERIF = 0;    // must be cleared by software
            }
            else    // dati validi  
            {
                // leggo gli N bytes ricevuti dal buffer circolare
                // per questo TEST 8 byte (in generale N byte dati dalla tabella di configurazione)
                for (i = 0; i < LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].config.data_length; i++)
                {
                    // se il buffer circolare di ricezione contiene almeno un byte
                    if (UART1_IsRxReady())
                        // scodo il buffer circolare di ricezione e copio i data byte nel payload corrispondente
                        LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].p_buffer->payload[i] = UART1_Read();
                }

                // alzo flag che notifica l'avvenuta ricezione di tutti i data byte per questo PID
                LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].p_buffer->flag_tx_rx_data_new = 1;
            }

            // scrivo il numero di data bytes che mi aspetto di riceve al prossimo giro (0 perche' mi aspetto solo un PID)
            U1P3 = 0;
            // configuro quando far scattare l'interrupt di ricezione dopo N byte di dato ricevuti
            U1STAHbits.URXISEL = 0;

            lin_state = LIN_ST__RX_PID;
        }
        break;

    default:
        break;
    }


    // 3. eventuali letture dummy per scodare il buffer circolare di ricezione
    // -------------------------------------------------------------------------
    for (i = 0; i < UART1_CONFIG_RX_BYTEQ_LENGTH; i++)
    {
        if (UART1_IsRxReady())
            temp_data = UART1_Read();
    }
    
#endif
    
    lin_new_msg = true;
    // 4. clear di eventuali flag di errore
    // -------------------------------------------------------------------------
    if (U1STAbits.ABDOVF)
    {
        // overflow del contatore BRG che calcola la baud rate (over during the auto-baud rate acquisition sequence)
        U1STAbits.ABDOVF = 0;
    }
    if (U1STAbits.OERR)
    {
        // receive buffer has overflowed
        U1STAbits.OERR = 0;
    }
    if (U1STAbits.CERIF)
    {
        // checksum error
        U1STAbits.CERIF = 0;
    }
    if (U1STAbits.TXCIF)
    {
        // transmit collision (transmitted word is not equal to the received word)
        U1STAbits.TXCIF = 0;
    }
    if (U1STAHbits.TXWRE)
    {
        // Write Transmit Error Status bit (a new byte was written when the buffer was full or when U1P2 = 0)
        U1STAHbits.TXWRE = 0;
    }
    

    // 5. clear interrupt flag di ricezione
    // -------------------------------------------------------------------------
    IFS0bits.U1RXIF = 0;
}

void UART1_SrvInt(void)
{
    uint8_t temp_data;
    uint8_t i;
        // 1. lettura dei dati ricevuti via LIN (PID oppure dati) e copia nel buffer circolare di ricezione
    // -------------------------------------------------------------------------
    while(!(U1STAHbits.URXBE == 1))
    {
        // scodo la FIFO di ricezione
        *rxTail = U1RXREG;

        // Will the increment not result in a wrap and not result in a pure collision?
        // This is most often condition so check first
        if ( ( rxTail    != (rxQueue + UART1_CONFIG_RX_BYTEQ_LENGTH-1)) &&
             ((rxTail+1) != rxHead) )
        {
            rxTail++;
        } 
        else if ( (rxTail == (rxQueue + UART1_CONFIG_RX_BYTEQ_LENGTH-1)) &&
                  (rxHead !=  rxQueue) )
        {
            // Pure wrap no collision
            rxTail = rxQueue;
        } 
        else // must be collision
        {
            rxOverflowed = true;
        }
    }


    // 2. verifica se ho ricevuto il PID o i dati
    // -------------------------------------------------------------------------
    switch (lin_state)
    {
    case LIN_ST__RX_PID:
        {
            // se ho ricevuto il segnale iniziale di SYNC brake
            if (U1STAbits.RXBKIF)
            {
                U1STAbits.RXBKIF = 0; // must be cleared by software

                // se c'e' un errore dei bit di parita' del PID (Protected ID)
                if (U1STAbits.PERR)
                {
                    // clear dell'errore e non faccio nient'altro (non considero i data byte e attendo un nuovo PID valido)
                    U1STAbits.PERR = 0;
                }
                else    // PID valido
                {
                    // lettura del ID dal buffer circolare di ricezione
                    if (UART1_IsRxReady())
                        lin_ID = (UART1_Read() & 0x3F);    // l'ID corrisponde ai 6 bit meno significativi del PID

                    // Ricerca se l'ID ricevuto corrisponde ad un message object LIN mappato
                    for (lin_msg_obj_idx = 0; lin_msg_obj_idx < LIN_MESSAGE_OBJ_TOTAL_NUMBER; lin_msg_obj_idx++)
                    {
                        // check se il message object LIN e' configurato
                        if (LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].config.valid)
                        {
                            if (LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].identifier == lin_ID)
                                break;  // ID message object LIN trovato!
                        }
                    }

                    if (lin_msg_obj_idx < LIN_MESSAGE_OBJ_TOTAL_NUMBER)
                    {
                        // message object LIN configurato come Slave transmission
                        if (LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].config.dir_0rx1tx)
                        {
                            // è per me
                            if (LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].nad == lin_pdu_node_address)
                            {
                                // copio nella variabile lin_pdu_protocol_request il frame ricevuto tramite LIN
                                LIN_rx_read_payload(lin_msg_obj_idx,
                                    (uint8_t*)&lin_pdu_protocol_request.payload, &lin_pdu_protocol_request.service);
                                lin_pdu_protocol_readDataByLocalIdentifier();
                                
                                if( lin_pdu_protocol_response.length )
                                {
                                    // preparo il buffer di risposta (che verra' trasmesso non appena verra' richeisto dal Master LIN)
                                    LIN_tx_update_payload(lin_msg_obj_idx,
                                           (uint8_t*)&lin_pdu_protocol_response.payload, lin_pdu_protocol_response.length);
                                    // configuro quanti byte deve trasmettere lo slave per questo ID
                                    LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].p_buffer->length = 8;
                                    U1P2 = LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].p_buffer->length;

                                    // reset della fifo di trasmissione U1TXREG
                                    U1STAHbits.UTXBE = 1;

                                    // Carico la fifo di trasmissione con i byte del payload da trasmettere
                                    for (i = 0; i < LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].p_buffer->length; i++)
                                    {
                                        U1TXREG = LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].p_buffer->payload[i];
                                    }
                                    // Da qui si occupa l'hardware della periferica UART a trasmettere..

                                    // alzo il flag che notifica l'avvenuta richiesta di trasmissione da parte del Master LIN
                                    LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].p_buffer->flag_tx_rx_data_new = 1;
                                }
                                
                                // pulisco la richiesta di trasmissione
                                //LIN_tx_clear_request();
                            }
                        }
                        else    // message object LIN configurato come Slave reception
                        {
                            // scrivo il numero di data bytes che mi aspetto di riceve per questo PID
                            U1P3 = LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].config.data_length;

                            // configuro quando far scattare l'interrupt di ricezione dopo N byte di dato ricevuti (in generale N - 1)
                            U1STAHbits.URXISEL = LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].config.data_length - 1;

                            // setto a zero il flag che va alto quando avro' ricevuto tutti i data byte per questo PID
                            LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].p_buffer->flag_tx_rx_data_new = 0;

                            lin_state = LIN_ST__RX_DATA;
                        }
                    }
                }
            }
        }
        break;

    case LIN_ST__RX_DATA:
        {
            // se c'e' stato un errore nel checksum dei dati
             if (U1STAbits.CERIF)
            {
                U1STAbits.CERIF = 0;    // must be cleared by software
            }
            else    // dati validi  
            {
                // leggo gli N bytes ricevuti dal buffer circolare
                // per questo TEST 8 byte (in generale N byte dati dalla tabella di configurazione)
                for (i = 0; i < LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].config.data_length; i++)
                {
                    // se il buffer circolare di ricezione contiene almeno un byte
                    if (UART1_IsRxReady())
                        // scodo il buffer circolare di ricezione e copio i data byte nel payload corrispondente
                        LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].p_buffer->payload[i] = UART1_Read();
                }

                // alzo flag che notifica l'avvenuta ricezione di tutti i data byte per questo PID
                LIN_OBJECT_DESCRIPTOR[lin_msg_obj_idx].p_buffer->flag_tx_rx_data_new = 1;
            }

            // scrivo il numero di data bytes che mi aspetto di riceve al prossimo giro (0 perche' mi aspetto solo un PID)
            U1P3 = 0;
            // configuro quando far scattare l'interrupt di ricezione dopo N byte di dato ricevuti
            U1STAHbits.URXISEL = 0;

            lin_state = LIN_ST__RX_PID;
        }
        break;

    default:
        break;
    }


    // 3. eventuali letture dummy per scodare il buffer circolare di ricezione
    // -------------------------------------------------------------------------
    for (i = 0; i < UART1_CONFIG_RX_BYTEQ_LENGTH; i++)
    {
        if (UART1_IsRxReady())
            temp_data = UART1_Read();
    }
    
}


/**
  Section: UART Driver Client Routines
*/
uint8_t UART1_Read(void)
{
    uint8_t data = 0;

//    while (rxHead == rxTail)
//    {
//    }
    
    data = *rxHead;

    rxHead++;

    if (rxHead == (rxQueue + UART1_CONFIG_RX_BYTEQ_LENGTH))
    {
        rxHead = rxQueue;
    }

    return data;
}


bool UART1_IsRxReady(void)
{    
    return !(rxHead == rxTail);
}


/*******************************************************************************

  !!! Deprecated API !!!
  !!! These functions will not be supported in future releases !!!

*******************************************************************************/

static uint8_t UART1_RxDataAvailable(void)
{
    uint16_t size;
    uint8_t *snapshot_rxTail = (uint8_t*)rxTail;
    
    if (snapshot_rxTail < rxHead) 
    {
        size = ( UART1_CONFIG_RX_BYTEQ_LENGTH - (rxHead-snapshot_rxTail));
    }
    else
    {
        size = ( (snapshot_rxTail - rxHead));
    }
    
    if(size > 0xFF)
    {
        return 0xFF;
    }
    
    return size;
}


unsigned int __attribute__((deprecated)) UART1_ReadBuffer( uint8_t *buffer ,  unsigned int numbytes)
{
    unsigned int rx_count = UART1_RxDataAvailable();
    unsigned int i;
    
    if(numbytes < rx_count)
    {
        rx_count = numbytes;
    }
    
    for(i=0; i<rx_count; i++)
    {
        *buffer++ = UART1_Read();
    }
    
    return rx_count;    
}

UART1_TRANSFER_STATUS __attribute__((deprecated)) UART1_TransferStatusGet (void )
{
    UART1_TRANSFER_STATUS status = 0;
    uint8_t rx_count = UART1_RxDataAvailable();
    
    switch(rx_count)
    {
        case 0:
            status |= UART1_TRANSFER_STATUS_RX_EMPTY;
            break;
        case UART1_CONFIG_RX_BYTEQ_LENGTH:
            status |= UART1_TRANSFER_STATUS_RX_FULL;
            break;
        default:
            status |= UART1_TRANSFER_STATUS_RX_DATA_PRESENT;
            break;
    }

    return status;    
}

uint8_t __attribute__((deprecated)) UART1_Peek(uint16_t offset)
{
    uint8_t *peek = rxHead + offset;
    
    while(peek > (rxQueue + UART1_CONFIG_RX_BYTEQ_LENGTH))
    {
        peek -= UART1_CONFIG_RX_BYTEQ_LENGTH;
    }
    
    return *peek;
}

bool __attribute__((deprecated)) UART1_ReceiveBufferIsEmpty (void)
{
    return (UART1_RxDataAvailable() == 0);
}


uint32_t __attribute__((deprecated)) UART1_StatusGet (void)
{
    uint32_t statusReg = U1STAH;
    return ((statusReg << 16 ) | U1STA);
}


unsigned int __attribute__((deprecated)) UART1_ReceiveBufferSizeGet(void)
{
    if(UART1_RxDataAvailable() != 0)
    {
        if(rxHead > rxTail)
        {
            return((rxHead - rxTail) - 1);
        }
        else
        {
            return((UART1_CONFIG_RX_BYTEQ_LENGTH - (rxTail - rxHead)) - 1);
        } 
    }
    return 0;
}

void __attribute__((deprecated)) UART1_Enable(void)
{
    U1MODEbits.UARTEN = 1;
    U1MODEbits.UTXEN = 1;
    U1MODEbits.URXEN = 1;
}

void __attribute__((deprecated)) UART1_Disable(void)
{
    U1MODEbits.UARTEN = 0;
    U1MODEbits.UTXEN = 0; 
    U1MODEbits.URXEN = 0;
}
