/* ****************************************************************************************
 * Project      : Tenneco LF - Applicativo
 * ****************************************************************************************
 * File Name    : lin_pdu_protocol.c
 * Description  : Protocollo Packet Data Unit (PDU) ovvero il transport layer frame
 *                su LIN per la lettura / scrittura di dati.
 * Note         :
 * **************************************************************************************** */


/* ---------------------------------------------------------------------------------------- */
/*  1.  PRIVATE INCLUDE FILES                                                               */
/* ---------------------------------------------------------------------------------------- */
#include "lin_pdu_protocol.h"
#include "lin.h"
#include "adc.h"
#include <string.h>
#include "version.h"
#include "full_bridge.h"
#include "igniter.h"
#include "eeprom.h"
#include "temperature.h"


#if 0
/* ---------------------------------------------------------------------------------------- */
/*  2.  PRIVATE MACROS ('define')                                                           */
/* ---------------------------------------------------------------------------------------- */
#define Service_ID_response(service_id)                 (service_id + 0x40)

// ========================================================================================
// SERVIZI
// ========================================================================================
// ID dei Diagnostic Services
#define SERVICE_ID_readDataByLocalIdentifier            (0x22)
#define SERVICE_ID_writeDataByLocalIdentifier           (0x2E)

// ID dei Configuration Services
#define CFG_SERVICE_ID_assignNAD                        (0xB0)
#define CFG_SERVICE_ID_readByIdentifier                 (0xB2)

#define SERVICE_ID_undefined                            (0xFF)


// ========================================================================================
// SOTTO-SERVIZI DEI DIAGNOSTIC SERVICES
// ========================================================================================
// ID dei sotto-servizi
// Local Identifier READ
#define LOCAL_READ_SERIAL_NUMBER                        (0x01)
#define LOCAL_READ_SW_VERSION_NUMBER                    (0x05)
#define LOCAL_READ_FULL_BRIDGE_FREQ                     (0x10)
#define LOCAL_READ_IGNITER_CURRENT                      (0x11)
#define LOCAL_READ_IGNITER_LAST_RESONANT_FREQ           (0x12)
#define LOCAL_READ_IGNITER_LAST_RESONANT_CURRENT        (0x13)
#define LOCAL_READ_IGNITER_1ST_RESONANT_FREQ            (0x14)
#define LOCAL_READ_IGNITER_CURRENT_MIN_THRESHOLD        (0x15)
#define LOCAL_READ_IGNITER_FREQ_STEP_LARGE              (0x16)
#define LOCAL_READ_IGNITER_FREQ_STEP_MICRO              (0x17)
#define LOCAL_READ_IGNITER_CONTROL_LOOP_SPEED           (0x18)  // not used
#define LOCAL_READ_NTC_TEMPERATURE                      (0x19)
#define LOCAL_READ_IGNITER_CONTROL_LOOP_PERIOD          (0x25)
#define LOCAL_READ_RESONANT_FREQUENCY_START             (0x26)
#define LOCAL_READ_FULL_BRIDGE_DUTY                     (0x27)
#define LOCAL_READ_IGNITER_WAIT_CONTROL_LOOP            (0x28)

// Local Identifier WRITE
#define LOCAL_WRITE_SERIAL_NUMBER                       (0x01)
#define LOCAL_WRITE_FULL_BRIDGE_MODE                    (0x10)
#define LOCAL_WRITE_FULL_BRIDGE_DUTY                    (0x11)
#define LOCAL_WRITE_FULL_BRIDGE_FREQ                    (0x12)
#define LOCAL_WRITE_IGNITER_CONTROL_LOOP_SPEED          (0x13)  // not used
#define LOCAL_WRITE_IGNITER_1ST_RESONANT_FREQ           (0x14)
#define LOCAL_WRITE_IGNITER_CURRENT_MIN_THRESHOLD       (0x15)
#define LOCAL_WRITE_IGNITER_FREQ_STEP_LARGE             (0x16)
#define LOCAL_WRITE_IGNITER_FREQ_STEP_MICRO             (0x17)
#define LOCAL_WRITE_IGNITER_TRIGGER_SOURCE              (0x18)
#define LOCAL_WRITE_IGNITER_CONTROL_LOOP_PERIOD         (0x22)
#define LOCAL_WRITE_IGNITER_RESONANT_FREQ_START         (0x23)
#define LOCAL_WRITE_IGNITER_WAIT_CONTROL_LOOP           (0x24)


// ========================================================================================
// SOTTO-SERVIZI DEI CONFIGURATION SERVICES
// ========================================================================================
// ID dei sotto-servizi
// Read by Identifier
#define READ_BY_IDENTIFIER__NAD_EEP                     (0x20)

#endif

#define LOCAL_WRITE_IGNITER_CONTROL_MODE                (0x01)
#define LOCAL_WRITE_IGNITER_TRIGGER_SOURCE              (0x02)
#define LOCAL_WRITE_FULL_BRIDGE_FREQ                    (0x03)
#define LOCAL_WRITE_IGNITER_RESONANT_FREQ_MAX           (0x04)
#define LOCAL_WRITE_IGNITER_RESONANT_FREQ_START         (0x05)
#define LOCAL_WRITE_IGNITER_CURRENT_SET_POINT           (0x06)
#define LOCAL_WRITE_IGNITER_CURRENT_MIN_THRESHOLD       (0x07)
#define LOCAL_WRITE_FULL_BRIDGE_DUTY                    (0x08)
#define LOCAL_WRITE_NODE_ADDRESS                        (0x09)
#define LOCAL_WRITE_IGNITER_CURRENT_STABLE              (0x0A)
#define LOCAL_WRITE_IGNITER_CURRENT_ERR_STABLE          (0x0B)
#define LOCAL_WRITE_IGNITER_CONTROL_LOOP_P              (0x0C)
#define LOCAL_WRITE_IGNITER_CONTROL_LOOP_I              (0x0D)
#define LOCAL_WRITE_IGNITER_CONTROL_F_STEP              (0x0E)
#define LOCAL_WRITE_IGNITER_CONTROL_MBSP_THR            (0x0F)
#define LOCAL_WRITE_IGNITER_CONTROL_MBSP_STEP           (0x10)
#define LOCAL_WRITE_IGNITER_CONTROL_MBSP_CNT_INIT       (0x11)
#define LOCAL_WRITE_IGNITER_CONTROL_I_HYST              (0x12)
#define LOCAL_WRITE_IGNITER_CONTROL_N_PERIOD            (0x13)
#define LOCAL_WRITE_IGNITER_CONTROL_CURR_STAB_CNT       (0x14)

// ========================================================================================
// CODICI DI ERRORE
// ========================================================================================
#define ERROR_CODE_GENERAL_REJECT                       (0x10)
#define ERROR_CODE_SERVICE_NOT_SUPPORTED                (0x11)
#define ERROR_CODE_LENGTH_MISMATCH                      (0x12)
#define ERROR_CODE_LOCAL_IDENTIFIER_NOT_SUPPORTED       (0x13)
#define ERROR_CODE_REQUEST_OUT_OF_RANGE                 (0x14)
#define ERROR_CODE_SUPPLIER_ID_MISMATCH                 (0x15)
#define ERROR_CODE_FUNCTION_ID_MISMATCH                 (0x16)
#define ERROR_CODE_NONE                                 (0x00)

// definizione valore dei byte di dato non usati
#define UNUSED_DATA_BYTE_VALUE                          (0xFF)


/* ---------------------------------------------------------------------------------------- */
/*  3.  PRIVATE TYPE DEFINITIONS ('typedef')                                                */
/* ---------------------------------------------------------------------------------------- */
// classe di servizio
typedef const struct LIN_PDU_P_SERVICE_stc {
    uint8_t service_id;         // identificativo del servizio (lettura o scrittura)
    uint8_t local_id;           // identificativo del sotto-servizio
    uint8_t length;             // numero di byte di dato (max 5 byte per il single frame) + 1 byte dell'identificativo del servizio (sotto-servizio e' il primo byte di dato)
                                // (valore max = 6 byte, avendo a disposzione 8 byte di payload / single frame, primi 2 byte per NAD and PCI_length)
} t_LIN_PDU_P_SERVICE_stc;


/* ---------------------------------------------------------------------------------------- */
/*  4.  PRIVATE VARIABLES AND CONSTANTS ('static')                                          */
/* ---------------------------------------------------------------------------------------- */
#ifdef EGICON
// servizi implementati
static /*const*/ t_LIN_PDU_P_SERVICE_stc lin_pdu_service[] =
{
    /*************************
     * DIAGNOSTIC SERVICES
     ************************/
    
    // READ SERVICES
    {   SERVICE_ID_readDataByLocalIdentifier,
        LOCAL_READ_SERIAL_NUMBER,
        0x3
    },
    {   SERVICE_ID_readDataByLocalIdentifier,
        LOCAL_READ_SW_VERSION_NUMBER,
        0x02
    },
    {   SERVICE_ID_readDataByLocalIdentifier,
        LOCAL_READ_FULL_BRIDGE_FREQ,
        0x02
    },
    {   SERVICE_ID_readDataByLocalIdentifier,
        LOCAL_READ_IGNITER_CURRENT,
        0x02
    },
    {   SERVICE_ID_readDataByLocalIdentifier,
        LOCAL_READ_IGNITER_LAST_RESONANT_FREQ,
        0x02
    },
    {   SERVICE_ID_readDataByLocalIdentifier,
        LOCAL_READ_IGNITER_LAST_RESONANT_CURRENT,
        0x02
    },
    {   SERVICE_ID_readDataByLocalIdentifier,
        LOCAL_READ_IGNITER_1ST_RESONANT_FREQ,
        0x02
    },
    {   SERVICE_ID_readDataByLocalIdentifier,
        LOCAL_READ_IGNITER_CURRENT_MIN_THRESHOLD,
        0x02
    },
    {   SERVICE_ID_readDataByLocalIdentifier,
        LOCAL_READ_IGNITER_FREQ_STEP_LARGE,
        0x02
    },
    {   SERVICE_ID_readDataByLocalIdentifier,
        LOCAL_READ_IGNITER_FREQ_STEP_MICRO,
        0x02
    },
    {   SERVICE_ID_readDataByLocalIdentifier,
        LOCAL_READ_IGNITER_CONTROL_LOOP_SPEED,
        0x02
    },
    {   SERVICE_ID_readDataByLocalIdentifier,
        LOCAL_READ_NTC_TEMPERATURE,
        0x03
    },
    {   SERVICE_ID_readDataByLocalIdentifier,
        LOCAL_READ_IGNITER_CONTROL_LOOP_PERIOD,
        0x02
    },
    {   SERVICE_ID_readDataByLocalIdentifier,
        LOCAL_READ_RESONANT_FREQUENCY_START,
        0x02
    },
    {   SERVICE_ID_readDataByLocalIdentifier,
        LOCAL_READ_FULL_BRIDGE_DUTY,
        0x02       
    },
    {   SERVICE_ID_readDataByLocalIdentifier,
        LOCAL_READ_IGNITER_WAIT_CONTROL_LOOP,
        0x02
    },    
    
    // WRITE SERVICES
    {   SERVICE_ID_writeDataByLocalIdentifier,
        LOCAL_WRITE_SERIAL_NUMBER,
        0x06
    },
    {   SERVICE_ID_writeDataByLocalIdentifier,
        LOCAL_WRITE_FULL_BRIDGE_MODE,
        0x03
    },
    {   SERVICE_ID_writeDataByLocalIdentifier,
        LOCAL_WRITE_FULL_BRIDGE_DUTY,
        0x04
    },
    {   SERVICE_ID_writeDataByLocalIdentifier,
        LOCAL_WRITE_FULL_BRIDGE_FREQ,
        0x06
    },
    {   SERVICE_ID_writeDataByLocalIdentifier,
        LOCAL_WRITE_IGNITER_CONTROL_LOOP_SPEED,
        0x03
    },
    {   SERVICE_ID_writeDataByLocalIdentifier,
        LOCAL_WRITE_IGNITER_1ST_RESONANT_FREQ,
        0x06
    },
    {   SERVICE_ID_writeDataByLocalIdentifier,
        LOCAL_WRITE_IGNITER_CURRENT_MIN_THRESHOLD,
        0x04
    },
    {   SERVICE_ID_writeDataByLocalIdentifier,
        LOCAL_WRITE_IGNITER_FREQ_STEP_LARGE,
        0x04
    },
    {   SERVICE_ID_writeDataByLocalIdentifier,
        LOCAL_WRITE_IGNITER_FREQ_STEP_MICRO,
        0x04
    },
    {   SERVICE_ID_writeDataByLocalIdentifier,
        LOCAL_WRITE_IGNITER_TRIGGER_SOURCE,
        0x03
    },
    {   SERVICE_ID_writeDataByLocalIdentifier,
        LOCAL_WRITE_IGNITER_CONTROL_LOOP_PERIOD,
        0x04
    },
    {   SERVICE_ID_writeDataByLocalIdentifier,
        LOCAL_WRITE_IGNITER_RESONANT_FREQ_START,
        0x06
    },
    {
        SERVICE_ID_writeDataByLocalIdentifier,
        LOCAL_WRITE_IGNITER_WAIT_CONTROL_LOOP,
        0x03
    },
    
    
    
    /*************************
     * CONFIGURATION SERVICES
     ************************/
    
    {   CFG_SERVICE_ID_assignNAD,
        (uint8_t) (SUPPLIER_ID & 0xFF), // LSB di SUPPLIER_ID (vedere doc del protocollo LIN)
        0x06
    },
    {   CFG_SERVICE_ID_readByIdentifier,
        READ_BY_IDENTIFIER__NAD_EEP,
        0x02
    },
    
    
    
    // EOF
    {   0x00,
        0x00,
        0x00
    }
};
#endif

uint8_t last_error_code = ERROR_CODE_GENERAL_REJECT;
uint8_t last_write_service_id;

/* ---------------------------------------------------------------------------------------- */
/*  5.  EXPORTED VARIABLES AND CONSTANTS (declared in header file with 'extern')            */
/* ---------------------------------------------------------------------------------------- */
uint16_t lin_params_to_store_flags;
uint8_t eol_params_to_store_flags;

// indirizzo del nodo slave LIN a livello di protocollo PDU
uint8_t lin_pdu_node_address;


/* ---------------------------------------------------------------------------------------- */
/*  6.  PRIVATE FUNCTION PROTOTYPES ('static')                                              */
/* ---------------------------------------------------------------------------------------- */

// Routine of Configuration Services
void lin_pdu_protocol_cfg__assignNAD(uint8_t node_address_for_response);
void lin_pdu_protocol_cfg__readByIdentifier(uint8_t node_address_for_response);


/* ---------------------------------------------------------------------------------------- */
/*  7.  PUBLIC FUNCTION DEFINITIONS                                                         */
/* ---------------------------------------------------------------------------------------- */
void LIN_PDU_PROTOCOL_init(void)
{
    // indirizzo nodo slave del protocollo LIN (predisposizione futura per configurazione da eeprom)
    //lin_pdu_node_address = EE_RAM.param.lf_lin_node_address;
    lin_pdu_node_address = 1;

    // ID servizio non definito nel caso mi venga chiesta una response senza mai aver fatto una prima request
    //lin_pdu_protocol_request.sf.service_id = SERVICE_ID_undefined;
    
    // clear della risposta (tutti i bytes uguali a 0xFF)
    memset(&lin_pdu_protocol_response, UNUSED_DATA_BYTE_VALUE, sizeof(t_LIN_PDU_PROTOCOL_stc));

    // in un sistema multi-slave non si deve più rispondere se non ho ricevuto un frame di request precedente
    //if (lin_pdu_node_address != NODE_ADDRESS__NOT_SUPPORTED)
    //{
    //    // default quando viene richiesta una risposta senza nessun frame di request precedente!
    //    lin_pdu_protocol_negative_response(lin_pdu_node_address, ERROR_CODE_GENERAL_REJECT);
    //}   
    // preparo il buffer di risposta (che verra' trasmesso se sara' richiesto dal Master LIN)
    //LIN_tx_update_payload(LIN_OBJ__PDU_PROTOCOL_RESPONSE,
    //                       (uint8_t*)&lin_pdu_protocol_response);
     
    lin_params_to_store_flags = 0;
    eol_params_to_store_flags = 0;
}


void LIN_PDU_PROTOCOL_task(void)
{
#if 1
    if (LIN_is_reception_completed(LIN_OBJ__WRITE))
    {
        // copio nella variabile lin_pdu_protocol_request il frame ricevuto tramite LIN
        LIN_rx_read_payload(LIN_OBJ__WRITE,
                            (uint8_t*)&lin_pdu_protocol_publish.payload, &lin_pdu_protocol_publish.service);
        
        if ( (lin_pdu_protocol_publish.payload.wf.nad == lin_pdu_node_address) ||
                  (lin_pdu_protocol_publish.payload.wf.nad == NODE_ADDRESS__BROADCAST)
                )
        {
        
            lin_pdu_protocol_writeDataByLocalIdentifier();
        }

#if 0
        // preparo la risposta alla request solo se la request e' indirizzata a me (uguaglianza nodo slave address)
        if (lin_pdu_protocol_request.node_address == NODE_ADDRESS__BROADCAST)
        {
            lin_pdu_prepare_response__broadcast();
        }
        else if ( (lin_pdu_protocol_request.node_address == lin_pdu_node_address) &&
                  (lin_pdu_protocol_request.node_address != NODE_ADDRESS__NOT_SUPPORTED)
                )
        {
            // elabora il messaggio ricevuto e prepara il messaggio di risposta
            lin_pdu_prepare_response();
        }
#endif
    }
#endif
}


/* ---------------------------------------------------------------------------------------- */
/*  8.  PRIVATE FUNCTION DEFINITIONS                                                        */
/* ---------------------------------------------------------------------------------------- */
#ifdef EGICON
void lin_pdu_prepare_response__broadcast(void)
{
    // clear della risposta (tutti i bytes uguali a 0xFF)
    memset(&lin_pdu_protocol_response,
           UNUSED_DATA_BYTE_VALUE,
           sizeof(t_LIN_PDU_PROTOCOL_stc));

    // Ricerca servizio broadcast
    switch (lin_pdu_protocol_request.sf.service_id)
    {
        case CFG_SERVICE_ID_assignNAD:
        {
            // Verifico campo lunghezza pacchetto
            if (lin_pdu_protocol_request.pci_length == 0x06)    // lunghezza pacchetto richiesta scrittura NAD
            {
                lin_pdu_protocol_cfg__assignNAD(NODE_ADDRESS__BROADCAST);
            }
            else    // lunghezza servizio errata
            {
                lin_pdu_protocol_negative_response(NODE_ADDRESS__BROADCAST, ERROR_CODE_LENGTH_MISMATCH);
            }
        }
        break;

        case CFG_SERVICE_ID_readByIdentifier:
        {
            // Verifico campo lunghezza pacchetto
            if (lin_pdu_protocol_request.pci_length == 0x02)    // lunghezza pacchetto richiesta scrittura NAD
            {
                lin_pdu_protocol_cfg__readByIdentifier(NODE_ADDRESS__BROADCAST);
            }
            else    // lunghezza servizio errata
            {
                lin_pdu_protocol_negative_response(NODE_ADDRESS__BROADCAST, ERROR_CODE_LENGTH_MISMATCH);
            }
        }
        break;

        default: // servizio non supportato
        {
            // errore: servizio non supportato
            lin_pdu_protocol_negative_response(NODE_ADDRESS__BROADCAST, ERROR_CODE_SERVICE_NOT_SUPPORTED);
        }
        break;
    }

    // preparo il buffer di risposta (che verra' trasmesso non appena verra' richeisto dal Master LIN)
    LIN_tx_update_payload(LIN_OBJ__PDU_PROTOCOL_RESPONSE,
                            (uint8_t*)&lin_pdu_protocol_response);
}
#endif

#ifdef EGICON
void lin_pdu_prepare_response(void)
{
    uint16_t subservice_idx;       // indice di lin_pdu_service[]
    uint8_t subservice_found;

    // clear della risposta (tutti i bytes uguali a 0xFF)
    memset(&lin_pdu_protocol_response,
           UNUSED_DATA_BYTE_VALUE,
           sizeof(t_LIN_PDU_PROTOCOL_stc));
        
    // verifico che il servizio sia disponibile tra quelli implementati
    if ( (lin_pdu_protocol_request.sf.service_id == SERVICE_ID_readDataByLocalIdentifier)   ||
         (lin_pdu_protocol_request.sf.service_id == SERVICE_ID_writeDataByLocalIdentifier)  ||  
         (lin_pdu_protocol_request.sf.service_id == CFG_SERVICE_ID_assignNAD)               ||
         (lin_pdu_protocol_request.sf.service_id == CFG_SERVICE_ID_readByIdentifier)
        )
    {
        // check sotto-servizio ricevuto
        subservice_idx = 0;
        subservice_found = 0;
        while(lin_pdu_service[subservice_idx].service_id != 0x00)
        {
            // cerco il sotto-servizio ricevuto tra quello disponibili in lin_pdu_service[]
            if (    (lin_pdu_protocol_request.sf.service_id     == lin_pdu_service[subservice_idx].service_id)
                 && (lin_pdu_protocol_request.sf.data1_local_id == lin_pdu_service[subservice_idx].local_id  )
               )
            {
                // sotto-servizio trovato!
                subservice_found = 1;
                break;
            }
            else
                subservice_idx++;
        }

        // sotto-servizio esistente
        if (subservice_found)
        {
            // verifico che la lunghezza del pacchetto del sotto-servizio corrispondi a quella del protocollo
            if (lin_pdu_protocol_request.pci_length == lin_pdu_service[subservice_idx].length)
            {
                switch (lin_pdu_protocol_request.sf.service_id)
                {
                    /*************************
                     * DIAGNOSTIC SERVICES
                     ************************/
                    case SERVICE_ID_readDataByLocalIdentifier:
                    {
                        lin_pdu_protocol_readDataByLocalIdentifier();
                    }
                    break;

                    case SERVICE_ID_writeDataByLocalIdentifier:
                    {
                        lin_pdu_protocol_writeDataByLocalIdentifier();
                    }
                    break;


                    /*************************
                     * CONFIGURATION SERVICES
                     ************************/
                    case CFG_SERVICE_ID_assignNAD:
                    {
                        lin_pdu_protocol_cfg__assignNAD(lin_pdu_node_address);
                    }   
                    break;

                    case CFG_SERVICE_ID_readByIdentifier:
                    {
                        lin_pdu_protocol_cfg__readByIdentifier(lin_pdu_node_address);
                    }   
                    break;

                    default:
                    {
                        // non dovrei mai cadere qui (check gia' fatto precedentemente)
                        lin_pdu_protocol_negative_response(lin_pdu_node_address, ERROR_CODE_LOCAL_IDENTIFIER_NOT_SUPPORTED);
                    }
                    break;
                }
            }
            else    // lunghezza servizio errata
            {
                lin_pdu_protocol_negative_response(lin_pdu_node_address, ERROR_CODE_LENGTH_MISMATCH);
            }
        }
        else    // sotto-servizio non supportato
        {
            // errore sotto-servizio non disponibile, preparo la risposta di errore
            lin_pdu_protocol_negative_response(lin_pdu_node_address, ERROR_CODE_LOCAL_IDENTIFIER_NOT_SUPPORTED);
        }
    }
    else    // servizio non supportato
    {
        // errore servizio non disponibile, preparo la risposta di errore
        lin_pdu_protocol_negative_response(lin_pdu_node_address, ERROR_CODE_SERVICE_NOT_SUPPORTED);
    }
    
    // preparo il buffer di risposta (che verra' trasmesso non appena verra' richeisto dal Master LIN)
    LIN_tx_update_payload(LIN_OBJ__PDU_PROTOCOL_RESPONSE,
                          (uint8_t*)&lin_pdu_protocol_response, lin_pdu_protocol_response.length);
}


void lin_pdu_protocol_negative_response(uint8_t node_address_for_response, uint8_t error_code)
{
    //lin_pdu_protocol_response.node_address      = node_address_for_response;
    //in_pdu_protocol_response.pci_length        = 0x03;
    //lin_pdu_protocol_response.sf.service_id     = 0x7F;
    //lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.service_id;
    lin_pdu_protocol_pub_feed.payload.rf.data0          = error_code;
    lin_pdu_protocol_pub_feed.length = 1;
}
#endif


void lin_pdu_protocol_readDataByLocalIdentifier(void)
{
    uint16_t u16_temp;
    uint32_t u32_temp;

    switch (lin_pdu_protocol_request.service)
    {
        case SERVICE_READ_SERIAL_NUMBER:
        {
            lin_pdu_protocol_response.payload.rf.data0 = EE_RAM.param.serial_number[0];    // SN_byte_LSB_1
            lin_pdu_protocol_response.payload.rf.data1 = EE_RAM.param.serial_number[1];    // SN_byte_LSB_1
            lin_pdu_protocol_response.payload.rf.data2 = EE_RAM.param.serial_number[2];    // SN_byte_LSB_1
            lin_pdu_protocol_response.payload.rf.data3 = EE_RAM.param.serial_number[3];    // SN_byte_LSB_1
            lin_pdu_protocol_response.payload.rf.data4 = EE_RAM.param.serial_number[4];    // SN_byte_LSB_1
            lin_pdu_protocol_response.payload.rf.data5 = EE_RAM.param.serial_number[5];    // SN_byte_LSB_1
            lin_pdu_protocol_response.length = 6;
        }
        break;
        
        case SERVICE_READ_SW_VERSION_NUMBER:
        {
            lin_pdu_protocol_response.payload.rf.data0 = sw_version[1];    // LSB
            lin_pdu_protocol_response.payload.rf.data1 = sw_version[0];    // MSB
            lin_pdu_protocol_response.length = 2;
        }
        break;

        case SERVICE_READ_IGNITER_CURRENT:
        {
            //__builtin_disable_interrupts();

//        // ultima lettura di corrente dell'ADC che puo' essere anche nulla se richiesta in un istante in cui l'igniter e' spento.
//        u16_temp = (uint16_t)(IGNITER_CURRENT_COUNTS);

            if (full_bridge.last_on_state == FULL_B_ST__ON_IGNITER_CONTROL)
                u16_temp = igniter.current_max_last;
            else
            if (full_bridge.last_on_state == FULL_B_ST__ON_CONTINUOUS)
                u16_temp = (uint16_t)(IGNITER_CURRENT_COUNTS);
            else
                u16_temp = full_bridge.current_max_last_on;

           // __builtin_enable_interrupts();
            lin_pdu_protocol_response.payload.rf.data0 = (uint8_t)((u16_temp     ) & 0x00FF);  // LSB
            lin_pdu_protocol_response.payload.rf.data1 = (uint8_t)((u16_temp >> 8) & 0x00FF);  // MSB
            lin_pdu_protocol_response.length = 2;
        }
        break;

#ifdef EGICON
        case LOCAL_READ_IGNITER_LAST_RESONANT_FREQ:
        {
            __builtin_disable_interrupts();

            u32_temp = (uint32_t)(igniter.last_resonant_freq__Hz);

            __builtin_enable_interrupts();

            lin_pdu_protocol_response.node_address      = lin_pdu_node_address;
            lin_pdu_protocol_response.pci_length        = 0x06;
            lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
            lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
            lin_pdu_protocol_response.sf.data2          = (uint8_t)((u32_temp      ) & 0xFF);  // LSB
            lin_pdu_protocol_response.sf.data3          = (uint8_t)((u32_temp >>  8) & 0xFF);  // m-LSB
            lin_pdu_protocol_response.sf.data4          = (uint8_t)((u32_temp >> 16) & 0xFF);  // m-MSB
            lin_pdu_protocol_response.sf.data5          = (uint8_t)((u32_temp >> 24) & 0xFF);  // MSB  
        }
        break;

        case LOCAL_READ_IGNITER_LAST_RESONANT_CURRENT:
        {
            __builtin_disable_interrupts();

            //u16_temp = (uint16_t)(igniter.current_at_resonance);

            __builtin_enable_interrupts();

            lin_pdu_protocol_response.node_address      = lin_pdu_node_address;
            lin_pdu_protocol_response.pci_length        = 0x04;
            lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
            lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
            lin_pdu_protocol_response.sf.data2          = (uint8_t)((u16_temp     ) & 0x00FF);  // LSB
            lin_pdu_protocol_response.sf.data3          = (uint8_t)((u16_temp >> 8) & 0x00FF);  // MSB
        }
        break;

        case LOCAL_READ_IGNITER_1ST_RESONANT_FREQ:
        {
            u32_temp = (uint32_t)EE_RAM.param.ign_1st_resonant_freq__Hz;

            lin_pdu_protocol_response.node_address      = lin_pdu_node_address;
            lin_pdu_protocol_response.pci_length        = 0x06;
            lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
            lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
            lin_pdu_protocol_response.sf.data2          = (uint8_t)((u32_temp      ) & 0xFF);  // LSB
            lin_pdu_protocol_response.sf.data3          = (uint8_t)((u32_temp >>  8) & 0xFF);  // m-LSB
            lin_pdu_protocol_response.sf.data4          = (uint8_t)((u32_temp >> 16) & 0xFF);  // m-MSB
            lin_pdu_protocol_response.sf.data5          = (uint8_t)((u32_temp >> 24) & 0xFF);  // MSB     
        }
        break;

        case LOCAL_READ_IGNITER_CURRENT_MIN_THRESHOLD:
        {
            u16_temp = (uint16_t)EE_RAM.param.ign_resonant_current_min_threshold;

            lin_pdu_protocol_response.node_address      = lin_pdu_node_address;
            lin_pdu_protocol_response.pci_length        = 0x04;
            lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
            lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
            lin_pdu_protocol_response.sf.data2          = (uint8_t)((u16_temp     ) & 0x00FF);  // LSB
            lin_pdu_protocol_response.sf.data3          = (uint8_t)((u16_temp >> 8) & 0x00FF);  // MSB
        }
        break;

        case LOCAL_READ_IGNITER_FREQ_STEP_LARGE:
        {
            u16_temp = (uint16_t)EE_RAM.param.ign_freq_step_large__Hz;

            lin_pdu_protocol_response.node_address      = lin_pdu_node_address;
            lin_pdu_protocol_response.pci_length        = 0x04;
            lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
            lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
            lin_pdu_protocol_response.sf.data2          = (uint8_t)((u16_temp     ) & 0x00FF);  // LSB
            lin_pdu_protocol_response.sf.data3          = (uint8_t)((u16_temp >> 8) & 0x00FF);  // MSB
        }
        break;

        case LOCAL_READ_IGNITER_FREQ_STEP_MICRO:
        {
            u16_temp = (uint16_t)EE_RAM.param.ign_freq_step_micro__Hz;

            lin_pdu_protocol_response.node_address      = lin_pdu_node_address;
            lin_pdu_protocol_response.pci_length        = 0x04;
            lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
            lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
            lin_pdu_protocol_response.sf.data2          = (uint8_t)((u16_temp     ) & 0x00FF);  // LSB
            lin_pdu_protocol_response.sf.data3          = (uint8_t)((u16_temp >> 8) & 0x00FF);  // MSB
        }
        break;

        case LOCAL_READ_IGNITER_CONTROL_LOOP_SPEED:
        {
            lin_pdu_protocol_response.node_address      = lin_pdu_node_address;
            lin_pdu_protocol_response.pci_length        = 0x03;
            lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
            lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
            lin_pdu_protocol_response.sf.data2          = EE_RAM.param.ign_control_loop_speed__N_cycles;
        }
        break;

        case LOCAL_READ_NTC_TEMPERATURE:
        {
            if (lin_pdu_protocol_request.sf.data2 > 0x01)
                lin_pdu_protocol_negative_response(lin_pdu_node_address, ERROR_CODE_REQUEST_OUT_OF_RANGE);
            else
            {
                if (lin_pdu_protocol_request.sf.data2 == 0x00)
                    u16_temp = (uint16_t)ADC_counts[AN_IN__NTC_TEMP1];
                else
                //if (lin_pdu_protocol_request.sf.data2 == 0x01)
                    u16_temp = (uint16_t)ADC_counts[AN_IN__NTC_TEMP2];

                lin_pdu_protocol_response.node_address      = lin_pdu_node_address;
                lin_pdu_protocol_response.pci_length        = 0x04;
                lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
                lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
                lin_pdu_protocol_response.sf.data2          = (uint8_t)((u16_temp     ) & 0x00FF);  // LSB
                lin_pdu_protocol_response.sf.data3          = (uint8_t)((u16_temp >> 8) & 0x00FF);  // MSB
            }
        }
        break;

        case LOCAL_READ_IGNITER_CONTROL_LOOP_PERIOD:
        {
            u16_temp = (uint16_t)EE_RAM.param.ign_control_loop_period;

            lin_pdu_protocol_response.node_address      = lin_pdu_node_address;
            lin_pdu_protocol_response.pci_length        = 0x04;
            lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
            lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
            lin_pdu_protocol_response.sf.data2          = (uint8_t)((u16_temp     ) & 0x00FF);  // LSB
            lin_pdu_protocol_response.sf.data3          = (uint8_t)((u16_temp >> 8) & 0x00FF);  // MSB
        }
        break;

        case LOCAL_READ_RESONANT_FREQUENCY_START:
        {
            u32_temp = (uint32_t)EE_RAM.param.ign_resonant_frequency_start__Hz;

            lin_pdu_protocol_response.node_address      = lin_pdu_node_address;
            lin_pdu_protocol_response.pci_length        = 0x06;
            lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
            lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
            lin_pdu_protocol_response.sf.data2          = (uint8_t)((u32_temp      ) & 0xFF);  // LSB
            lin_pdu_protocol_response.sf.data3          = (uint8_t)((u32_temp >>  8) & 0xFF);  // m-LSB
            lin_pdu_protocol_response.sf.data4          = (uint8_t)((u32_temp >> 16) & 0xFF);  // m-MSB
            lin_pdu_protocol_response.sf.data5          = (uint8_t)((u32_temp >> 24) & 0xFF);  // MSB 
        }
        break;    

        case LOCAL_READ_FULL_BRIDGE_DUTY:
        {
            u16_temp = (uint16_t)EE_RAM.param.full_bridge_duty_cycle__10bit;

            lin_pdu_protocol_response.node_address      = lin_pdu_node_address;
            lin_pdu_protocol_response.pci_length        = 0x04;
            lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
            lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
            lin_pdu_protocol_response.sf.data2          = (uint8_t)((u16_temp     ) & 0x00FF);  // LSB
            lin_pdu_protocol_response.sf.data3          = (uint8_t)((u16_temp >> 8) & 0x00FF);  // MSB
        }
        break; 

        case LOCAL_READ_IGNITER_WAIT_CONTROL_LOOP:
        {
            lin_pdu_protocol_response.node_address      = lin_pdu_node_address;
            lin_pdu_protocol_response.pci_length        = 0x03;
            lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
            lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
            lin_pdu_protocol_response.sf.data2          = EE_RAM.param.ign_wait_control__N_cycles;
        }
        break;    

        default:
        {
            // sotto-servizio non supportato
            lin_pdu_protocol_negative_response(lin_pdu_node_address, ERROR_CODE_LOCAL_IDENTIFIER_NOT_SUPPORTED);
        }
        break;
#else
        case SERVICE_READ_IGNITER_LAST_RESONANT_FREQ:
        {
            //__builtin_disable_interrupts();

            u32_temp = (uint32_t)(igniter.last_resonant_freq__Hz);
            u32_temp = 62000;
            //__builtin_enable_interrupts();
            lin_pdu_protocol_response.payload.rf.data0 = (uint8_t)((u32_temp      ) & 0xFF);  // LSB
            lin_pdu_protocol_response.payload.rf.data1 = (uint8_t)((u32_temp >>  8) & 0xFF);  // m-LSB
            lin_pdu_protocol_response.payload.rf.data2 = (uint8_t)((u32_temp >> 16) & 0xFF);  // m-MSB
            lin_pdu_protocol_response.payload.rf.data3 = (uint8_t)((u32_temp >> 24) & 0xFF);  // MSB  
            lin_pdu_protocol_response.length = 4;
        }
        break;
        
        case SERVICE_READ_NODE_ADDRESS:
        {
            lin_pdu_protocol_response.payload.rf.data0 = lin_pdu_node_address; 
            lin_pdu_protocol_response.length = 1;
        }
        break;
        
        case SERVICE_READ_DIAGNOSTICS:
        {
            //if( igniter_new_diagnostics )
            if(1)
            {
                u32_temp = (uint32_t)(igniter.last_resonant_freq__Hz);
                //u32_temp = 100000;
                //u16_temp = (uint16_t)(igniter.last_resonant_freq__Hz/100);
                u16_temp = (uint16_t)(u32_temp/100);

                lin_pdu_protocol_response.payload.rf.data0 = (uint8_t)((u16_temp     ) & 0x00FF);  // LSB
                lin_pdu_protocol_response.payload.rf.data1 = (uint8_t)((u16_temp >> 8) & 0x000F);  // MSB

                if (full_bridge.last_on_state == FULL_B_ST__ON_IGNITER_CONTROL)
                    u16_temp = igniter.current_max_last;
                else
                if (full_bridge.last_on_state == FULL_B_ST__ON_CONTINUOUS)
                    u16_temp = (uint16_t)(IGNITER_CURRENT_COUNTS);
                else
                    u16_temp = full_bridge.current_max_last_on;

                //u16_temp = 1200;
                u16_temp <<= 4;
               // __builtin_enable_interrupts();
                lin_pdu_protocol_response.payload.rf.data1 |= (uint8_t)((u16_temp << 4     ) & 0x00F0);  // LSB
                lin_pdu_protocol_response.payload.rf.data2 = (uint8_t)((u16_temp >> 8) & 0x00FF);  // MSB

                lin_pdu_protocol_response.payload.rf.data3 = (uint8_t)ADC_counts[AN_IN__NTC_TEMP1];
                lin_pdu_protocol_response.payload.rf.data4 = (uint8_t)ADC_counts[AN_IN__NTC_TEMP2];
                lin_pdu_protocol_response.length = 4;
                
                igniter_new_diagnostics = 0;
            }
            else
            {
                lin_pdu_protocol_response.length = 0;   
            }
        }
        break;
        
        case SERVICE_ACKNOWLEDGE:
        {
            lin_pdu_protocol_response.payload.rf.data1 = last_error_code;
            lin_pdu_protocol_response.payload.rf.data0 = last_write_service_id; 
            lin_pdu_protocol_response.length = 2;
        }
        break;
        
        default:
            
        break;
#endif
    }
}


void lin_pdu_protocol_writeDataByLocalIdentifier(void)
{
    uint16_t u16_temp;
    uint32_t u32_temp;
    
    last_error_code = ERROR_CODE_NONE;
    last_write_service_id = lin_pdu_protocol_publish.payload.wf.service_id;
    
    switch (lin_pdu_protocol_publish.payload.wf.service_id)
    {
        
        case LOCAL_WRITE_IGNITER_CONTROL_MODE:
        {
            if (FULL_BRIDGE_mode_set((t_FULL_B_MODE_en)lin_pdu_protocol_publish.payload.wf.data0) != Ok)
                last_error_code = ERROR_CODE_REQUEST_OUT_OF_RANGE;
            
        }
        break;

        case LOCAL_WRITE_FULL_BRIDGE_DUTY:
        {
            u16_temp = (uint16_t)(0UL | ((uint16_t)lin_pdu_protocol_publish.payload.wf.data1 << 8) | (uint16_t)lin_pdu_protocol_publish.payload.wf.data0);

            if (FULL_BRIDGE_change_duty(u16_temp) != Ok)
                last_error_code = ERROR_CODE_REQUEST_OUT_OF_RANGE;
            else 
            {
                EE_update_param(EE_PARAM_FULL_BRIDGE_DUTY, (uint32_t)pwm_full_bridge.duty_cycle);
                FULL_BRIDGE_PARAM_set_request_to_store(FULL_BRIDGE_PARAM__DUTY_CYCLE); // salvataggio in memoria non volatile non appena igniter (full-bridge) passa da ON a OFF -> IGNITER_task_when_off
            }
        }
        break;

        case LOCAL_WRITE_FULL_BRIDGE_FREQ:
        {
            u32_temp = (uint32_t)(0UL | 
                                ((uint32_t)lin_pdu_protocol_publish.payload.wf.data3 << 24) | 
                                ((uint32_t)lin_pdu_protocol_publish.payload.wf.data2 << 16) |
                                ((uint32_t)lin_pdu_protocol_publish.payload.wf.data1 <<  8) | 
                                 (uint32_t)lin_pdu_protocol_publish.payload.wf.data0);

            // Verificare che non stia funzionando con il current loop attivo, non posso modificare la frequenza 
            // istantaneamente se ho il loop di controllo attivo
            if (igniter.trigger_source != IGN_TRIG_SOURCE_NONE)
            {
                last_error_code = ERROR_CODE_GENERAL_REJECT; 
            }
            else
            {
                if (FULL_BRIDGE_change_frequency(u32_temp) != Ok)
                    last_error_code = ERROR_CODE_REQUEST_OUT_OF_RANGE;
                else
                {
                    FULL_BRIDGE_clear_variable();          
                }
            }
        }
        break;
        

        case LOCAL_WRITE_IGNITER_TRIGGER_SOURCE:
        {
             if (IGNITER_trigger_source_set(lin_pdu_protocol_publish.payload.wf.data0) != Ok)
                last_error_code = ERROR_CODE_REQUEST_OUT_OF_RANGE;
             
            //else
            //{
                //memcpy( &lin_pdu_protocol_pub_feed, &lin_pdu_protocol_publish, sizeof(t_LIN_PDU_PROTOCOL_stc));
                //lin_pdu_protocol_response.node_address      = lin_pdu_node_address;
                //lin_pdu_protocol_response.pci_length        = 0x03;
                //lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
                //lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
                //lin_pdu_protocol_response.sf.data2          = lin_pdu_protocol_request.sf.data2;
           // }
            
        }
        break;
        
        case LOCAL_WRITE_IGNITER_RESONANT_FREQ_START:
        {
            u32_temp = (uint32_t)(0UL | 
                                ((uint32_t)lin_pdu_protocol_publish.payload.wf.data3 << 24) | 
                                ((uint32_t)lin_pdu_protocol_publish.payload.wf.data2 << 16) |
                                ((uint32_t)lin_pdu_protocol_publish.payload.wf.data1 <<  8) | 
                                 (uint32_t)lin_pdu_protocol_publish.payload.wf.data0);

            if (    (u32_temp < IGN_RESONANT_FREQ_START_MIN__Hz)
                 || (u32_temp > IGN_RESONANT_FREQ_START_MAX__Hz)
               )
                last_error_code = ERROR_CODE_REQUEST_OUT_OF_RANGE;
            else
            {
                // Quando modifico la frequenza minima da cui iniziare la ricerca della risonanza, devo anche ripulire la prequenza di risonanza
                // eventualmente già trovata; di cosneguenza aggiorno anche il parametro EE_RAM.param.ign_1st_resonant_freq__Hz
                EE_update_param(EE_PARAM_IGN_RESONANT_FREQ_START, (uint32_t)u32_temp);
                IGN_PARAM_set_request_to_store(IGNITER_PARAM__RESONANT_FREQUENCY_START);  // salvataggio in memoria non volatile non appena igniter (full-bridge) passa da ON a OFF -> IGNITER_task_when_off

                // richiesta di aggiornamento del paramtro EE_RAM.param.ign_1st_resonant_freq__Hz
                // NOTA: non faccio l'update in EE_RAM qui perche' non voglio cambiare is_1st_resonant_frequency_found() che usa il parametro in EE_RAM
                ign_1st_resonant_freq__Hz_to_store_new = IGN_1ST_RESONANT_FREQ_UNDEFINED__Hz;
                IGN_PARAM_set_request_to_store(IGNITER_PARAM__1ST_RESONANT_FREQ);   // salvataggio in memoria non volatile non appena igniter (full-bridge) passa da ON a OFF -> IGNITER_task_when_off
            }
        }
        break;
        
        case LOCAL_WRITE_IGNITER_CURRENT_SET_POINT:
        {
            u16_temp = (uint32_t)(0UL | 
                                ((uint16_t)lin_pdu_protocol_publish.payload.wf.data1 <<  8) | 
                                 (uint16_t)lin_pdu_protocol_publish.payload.wf.data0);

            if (    (    (u16_temp < IGN_CONTROL_CURR_SP_MIN)
                      || (u16_temp > IGN_CONTROL_CURR_SP_MAX)
                    )
               )
                last_error_code = ERROR_CODE_REQUEST_OUT_OF_RANGE;
            else
            {
                EE_update_param(EE_PARAM_IGN_CONTROL_CURR_SETPOINT, (uint32_t)u16_temp);
                IGN_PARAM_set_request_to_store(IGNITER_PARAM__SET_POINT_CURR);  // salvataggio in memoria non volatile non appena igniter (full-bridge) passa da ON a OFF -> IGNITER_task_when_off
            }
        }
        break;
        
        case LOCAL_WRITE_IGNITER_CURRENT_MIN_THRESHOLD:
        {
            u16_temp = (uint16_t)(0UL | ((uint16_t)lin_pdu_protocol_publish.payload.wf.data1 << 8) | (uint16_t)lin_pdu_protocol_publish.payload.wf.data0);

            if (    (u16_temp < IGN_RES_CURRENT_MIN_THRESHOLD_MIN)
                 || (u16_temp > IGN_RES_CURRENT_MIN_THRESHOLD_MAX)
               )
                last_error_code = ERROR_CODE_REQUEST_OUT_OF_RANGE;
            else
            {
                EE_update_param(EE_PARAM_IGN_CURRENT_MIN_THRES, (uint32_t)u16_temp);
                IGN_PARAM_set_request_to_store(IGNITER_PARAM__RESONANT_CURRENT_MIN_THRESHOLD);  // salvataggio in memoria non volatile non appena igniter (full-bridge) passa da ON a OFF -> IGNITER_task_when_off
            }
        }
        break;
        
        case LOCAL_WRITE_IGNITER_CURRENT_STABLE:
        {
            u16_temp = (uint16_t)(0UL | ((uint16_t)lin_pdu_protocol_publish.payload.wf.data1 << 8) | (uint16_t)lin_pdu_protocol_publish.payload.wf.data0);

            if (    (u16_temp < IGN_CONTROL_CURRENT_STABLE_MIN)
                 || (u16_temp > IGN_CONTROL_CURRENT_STABLE_MAX)
               )
                last_error_code = ERROR_CODE_REQUEST_OUT_OF_RANGE;
            else
            {
                EE_update_param(EE_PARAM_IGN_CONTROL_CURR_STABLE, (uint32_t)u16_temp);
                IGN_PARAM_set_request_to_store(IGNITER_PARAM__MIN_STAB_CURR);  // salvataggio in memoria non volatile non appena igniter (full-bridge) passa da ON a OFF -> IGNITER_task_when_off
            }
        }
        break;
        
        case LOCAL_WRITE_IGNITER_CURRENT_ERR_STABLE:
        {
            if (    (lin_pdu_protocol_publish.payload.wf.data0 < IGN_CONTROL_ERR_STABLE_MIN)
                 || (lin_pdu_protocol_publish.payload.wf.data0 > IGN_CONTROL_ERR_STABLE_MAX)
               )
                last_error_code = ERROR_CODE_REQUEST_OUT_OF_RANGE;
            else
            {
                EE_update_param(EE_PARAM_IGN_CONTROL_ERR_STABLE, (uint32_t)lin_pdu_protocol_publish.payload.wf.data0);
                IGN_PARAM_set_request_to_store(IGNITER_PARAM__STAB_CURR_ERR);  // salvataggio in memoria non volatile non appena igniter (full-bridge) passa da ON a OFF -> IGNITER_task_when_off
            }
        }
        break;
        
        case LOCAL_WRITE_IGNITER_CONTROL_LOOP_P:
        {
            if (    (lin_pdu_protocol_publish.payload.wf.data0 < IGN_CONTROL_LOOP_P_MIN)
                 || (lin_pdu_protocol_publish.payload.wf.data0 > IGN_CONTROL_LOOP_P_MAX)
               )
                last_error_code = ERROR_CODE_REQUEST_OUT_OF_RANGE;
            else
            {
                EE_update_param(EE_PARAM_IGN_CONTROL_LOOP_P, (uint32_t)lin_pdu_protocol_publish.payload.wf.data0);
                IGN_PARAM_set_request_to_store(IGNITER_PARAM__KP);  // salvataggio in memoria non volatile non appena igniter (full-bridge) passa da ON a OFF -> IGNITER_task_when_off
            }
        }
        break;
        
        
        case LOCAL_WRITE_IGNITER_CONTROL_LOOP_I:
        {
            if (    (lin_pdu_protocol_publish.payload.wf.data0 < IGN_CONTROL_LOOP_I_MIN)
                 || (lin_pdu_protocol_publish.payload.wf.data0 > IGN_CONTROL_LOOP_I_MAX)
               )
                last_error_code = ERROR_CODE_REQUEST_OUT_OF_RANGE;
            else
            {
                EE_update_param(EE_PARAM_IGN_CONTROL_LOOP_I, (uint32_t)lin_pdu_protocol_publish.payload.wf.data0);
                IGN_PARAM_set_request_to_store(IGNITER_PARAM__KI);  // salvataggio in memoria non volatile non appena igniter (full-bridge) passa da ON a OFF -> IGNITER_task_when_off
            }
        }
        break;
           
        case LOCAL_WRITE_IGNITER_CONTROL_F_STEP:
        {
            u16_temp = (uint16_t)(0UL | ((uint16_t)lin_pdu_protocol_publish.payload.wf.data1 << 8) | (uint16_t)lin_pdu_protocol_publish.payload.wf.data0);

            if (    (u16_temp < IGN_CONTROL_F_STEP_MIN)
                 || (u16_temp > IGN_CONTROL_F_STEP_MAX)
               )
                last_error_code = ERROR_CODE_REQUEST_OUT_OF_RANGE;
            else
            {
                EE_update_param(EE_PARAM_IGN_CONTROL_F_STEP, (uint32_t)u16_temp);
                IGN_PARAM_set_request_to_store(IGNITER_PARAM__FREQ_STEP);  // salvataggio in memoria non volatile non appena igniter (full-bridge) passa da ON a OFF -> IGNITER_task_when_off
            }
        }
        break;
        
        case LOCAL_WRITE_IGNITER_CONTROL_MBSP_THR:
        {
            u16_temp = (uint16_t)(0UL | ((uint16_t)lin_pdu_protocol_publish.payload.wf.data1 << 8) | (uint16_t)lin_pdu_protocol_publish.payload.wf.data0);

            if (    (u16_temp < IGN_CONTROL_MBSP_THR_MIN)
                 || (u16_temp > IGN_CONTROL_MBSP_THR_MAX)
               )
                last_error_code = ERROR_CODE_REQUEST_OUT_OF_RANGE;
            else
            {
                EE_update_param(EE_PARAM_IGN_CONTROL_MBSP_THR, (uint32_t)u16_temp);
                IGN_PARAM_set_request_to_store(IGNITER_PARAM__MBSP_THR_ERR);  // salvataggio in memoria non volatile non appena igniter (full-bridge) passa da ON a OFF -> IGNITER_task_when_off
            }
        }
        break;
        
        case LOCAL_WRITE_IGNITER_CONTROL_MBSP_STEP:
        {
            u16_temp = (uint16_t)(0UL | ((uint16_t)lin_pdu_protocol_publish.payload.wf.data1 << 8) | (uint16_t)lin_pdu_protocol_publish.payload.wf.data0);

            if (    (u16_temp < IGN_CONTROL_MBSP_STEP_MIN)
                 || (u16_temp > IGN_CONTROL_MBSP_STEP_MAX)
               )
                last_error_code = ERROR_CODE_REQUEST_OUT_OF_RANGE;
            else
            {
                EE_update_param(EE_PARAM_IGN_CONTROL_MBSP_STEP, (uint32_t)u16_temp);
                IGN_PARAM_set_request_to_store(IGNITER_PARAM__MBSP_STEP);  // salvataggio in memoria non volatile non appena igniter (full-bridge) passa da ON a OFF -> IGNITER_task_when_off
            }
        }
        break;
        
        
        case LOCAL_WRITE_IGNITER_CONTROL_MBSP_CNT_INIT:
        {
            if (    (lin_pdu_protocol_publish.payload.wf.data0 < IGN_CONTROL_MBSP_CNT_INIT_MIN)
                 || (lin_pdu_protocol_publish.payload.wf.data0 > IGN_CONTROL_MBSP_CNT_INIT_MAX)
               )
                last_error_code = ERROR_CODE_REQUEST_OUT_OF_RANGE;
            else
            {
                EE_update_param(EE_PARAM_IGN_CONTROL_MBSP_CNT_INIT, (uint32_t)lin_pdu_protocol_publish.payload.wf.data0);
                IGN_PARAM_set_request_to_store(IGNITER_PARAM__MBSP_CNT_INIT);  // salvataggio in memoria non volatile non appena igniter (full-bridge) passa da ON a OFF -> IGNITER_task_when_off
            }
        }
        break;
        
        
        case LOCAL_WRITE_IGNITER_CONTROL_I_HYST:
        {
            u16_temp = (uint16_t)(0UL | ((uint16_t)lin_pdu_protocol_publish.payload.wf.data1 << 8) | (uint16_t)lin_pdu_protocol_publish.payload.wf.data0);

            if (    (u16_temp < IGN_CONTROL_CURR_HYST_MIN)
                 || (u16_temp > IGN_CONTROL_CURR_HYST_MAX)
               )
                last_error_code = ERROR_CODE_REQUEST_OUT_OF_RANGE;
            else
            {
                EE_update_param(EE_PARAM_IGN_CONTROL_I_HYST, (uint32_t)u16_temp);
                IGN_PARAM_set_request_to_store(IGNITER_PARAM__CURR_HYST);  // salvataggio in memoria non volatile non appena igniter (full-bridge) passa da ON a OFF -> IGNITER_task_when_off
            }
        }
        break;
        
        
        case LOCAL_WRITE_IGNITER_CONTROL_N_PERIOD:
        {
            u16_temp = (uint16_t)(0UL | ((uint16_t)lin_pdu_protocol_publish.payload.wf.data1 << 8) | (uint16_t)lin_pdu_protocol_publish.payload.wf.data0);

            if (    (u16_temp < IGN_CONTROL_CTRL_PER_MIN)
                 || (u16_temp > IGN_CONTROL_CTRL_PER_MAX)
               )
                last_error_code = ERROR_CODE_REQUEST_OUT_OF_RANGE;
            else
            {
                EE_update_param(EE_PARAM_IGN_CONTROL_CTRL_N_PER, (uint32_t)u16_temp);
                IGN_PARAM_set_request_to_store(IGNITER_PARAM__CONTROL_LOOP_PERIOD);  // salvataggio in memoria non volatile non appena igniter (full-bridge) passa da ON a OFF -> IGNITER_task_when_off
            }
        }
        break;
        
        
        case LOCAL_WRITE_IGNITER_CONTROL_CURR_STAB_CNT:
        {
            u16_temp = (uint16_t)(0UL | ((uint16_t)lin_pdu_protocol_publish.payload.wf.data1 << 8) | (uint16_t)lin_pdu_protocol_publish.payload.wf.data0);

            if (    (u16_temp < IGN_CONTROL_CURR_STAB_CNT_MIN)
                 || (u16_temp > IGN_CONTROL_CURR_STAB_CNT_MAX)
               )
                last_error_code = ERROR_CODE_REQUEST_OUT_OF_RANGE;
            else
            {
                EE_update_param(EE_PARAM_IGN_CONTROL_CURR_STAB_CNT, (uint32_t)u16_temp);
                IGN_PARAM_set_request_to_store(IGNITER_PARAM__STAB_CURR_CNT);  // salvataggio in memoria non volatile non appena igniter (full-bridge) passa da ON a OFF -> IGNITER_task_when_off
            }
        }
        break;

        
        case LOCAL_WRITE_NODE_ADDRESS:
        {
            // Check del NEW_NAD
            if ( (lin_pdu_protocol_publish.payload.wf.data0 < NODE_ADDRESS__MIN_VALUE) ||
                 (lin_pdu_protocol_publish.payload.wf.data0 > NODE_ADDRESS__MAX_VALUE)
                )
            {
                // Out of range
                last_error_code = ERROR_CODE_REQUEST_OUT_OF_RANGE;
            }
            else
            {
                EE_update_param(EE_PARAM_NAD, lin_pdu_protocol_publish.payload.wf.data0);
                LIN_PARAM_set_request_to_store(LIN_PARAM__NAD)  // salvataggio in memoria non volatile sfruttando la scrittura in eeprom degli altri parametri
                // il nuovo indirizzo viene salvato nella variabile lin_pdu_node_address quando eseguo il salvataggio in eeprom -> funzione IGNITER_task_when_off        

                //memcpy( &lin_pdu_protocol_pub_feed, &lin_pdu_protocol_publish, sizeof(t_LIN_PDU_PROTOCOL_stc));
                //lin_pdu_protocol_response.node_address      = node_address_for_response;
                //lin_pdu_protocol_response.pci_length        = 0x01;
                //lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
            }
#if 0
            // Check del SUPPLIER_ID
            if ( (lin_pdu_protocol_publish.payload.wf.data0 == (SUPPLIER_ID & 0xFF)) &&    // LSB
                 (lin_pdu_protocol_publish.payload.wf.data1 == ((SUPPLIER_ID >> 8) & 0xFF))         // MSB
                )
            {
                // Check del FUNCTION_ID
                if ( (lin_pdu_protocol_publish.payload.wf.data2 == (FUNCTION_ID & 0xFF)) &&         // LSB
                     (lin_pdu_protocol_publish.payload.wf.data3 == ((FUNCTION_ID >> 8) & 0xFF))     // MSB
                    )
                {
                    // Check del NEW_NAD
                    if ( (lin_pdu_protocol_publish.payload.wf.data4 < NODE_ADDRESS__MIN_VALUE) ||
                         (lin_pdu_protocol_publish.payload.wf.data4 > NODE_ADDRESS__MAX_VALUE)
                        )
                    {
                        // Out of range
                        last_error_code = ERROR_CODE_REQUEST_OUT_OF_RANGE;
                    }
                    else
                    {
                        EE_update_param(EE_PARAM_NAD, lin_pdu_protocol_publish.payload.wf.data4);
                        LIN_PARAM_set_request_to_store(LIN_PARAM__NAD)  // salvataggio in memoria non volatile sfruttando la scrittura in eeprom degli altri parametri
                        // il nuovo indirizzo viene salvato nella variabile lin_pdu_node_address quando eseguo il salvataggio in eeprom -> funzione IGNITER_task_when_off        

                        //memcpy( &lin_pdu_protocol_pub_feed, &lin_pdu_protocol_publish, sizeof(t_LIN_PDU_PROTOCOL_stc));
                        //lin_pdu_protocol_response.node_address      = node_address_for_response;
                        //lin_pdu_protocol_response.pci_length        = 0x01;
                        //lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
                    }
                }
                else
                {
                    // FUNCTION_ID errato
                    last_error_code = ERROR_CODE_FUNCTION_ID_MISMATCH;
                }
            }
            else
            {
                // SUPPLIER_ID errato
                last_error_code = ERROR_CODE_SUPPLIER_ID_MISMATCH;
            }
            
#endif
            
        }
        break;
        
        default:
            
        break;
        
    }

#ifdef EGICON 
    switch (lin_pdu_protocol_request.sf.data1_local_id)
    {
        case LOCAL_WRITE_SERIAL_NUMBER:
        {
            if ( (lin_pdu_protocol_request.sf.data2 < SN_BYTE_LSB__) ||
                 (lin_pdu_protocol_request.sf.data2 > SN_BYTE_MSB__) )
            {
                lin_pdu_protocol_negative_response(lin_pdu_node_address, ERROR_CODE_REQUEST_OUT_OF_RANGE);
            }
            else
            {
                if (lin_pdu_protocol_request.sf.data2 == SN_BYTE_LSB__)  // X = LSB -> SN_byte_LSB_#
                {
                    EE_update_param(EE_PARAM_SERIAL_NUMBER0, lin_pdu_protocol_request.sf.data3);    // SN_byte_LSB_1
                    EE_update_param(EE_PARAM_SERIAL_NUMBER1, lin_pdu_protocol_request.sf.data4);    // SN_byte_LSB_2
                    EE_update_param(EE_PARAM_SERIAL_NUMBER2, lin_pdu_protocol_request.sf.data5);    // SN_byte_LSB_3
                }
                else    // X = MSB -> SN_byte_MSB_# 
                {
                    EE_update_param(EE_PARAM_SERIAL_NUMBER3, lin_pdu_protocol_request.sf.data3);    // SN_byte_MSB_1
                    EE_update_param(EE_PARAM_SERIAL_NUMBER4, lin_pdu_protocol_request.sf.data4);    // SN_byte_MSB_2
                    EE_update_param(EE_PARAM_SERIAL_NUMBER5, lin_pdu_protocol_request.sf.data5);    // SN_byte_MSB_3
                }
                EOL_PARAM_set_request_to_store(); // salvataggio in memoria non volatile non appena igniter (full-bridge) passa da ON a OFF -> IGNITER_task_when_off
                
                lin_pdu_protocol_response.node_address      = lin_pdu_node_address;
                lin_pdu_protocol_response.pci_length        = 0x06;
                lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
                lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
                lin_pdu_protocol_response.sf.data2          = lin_pdu_protocol_request.sf.data2;    // SN_portion -> X
                lin_pdu_protocol_response.sf.data3          = lin_pdu_protocol_request.sf.data3;    // SN_byte_X_1
                lin_pdu_protocol_response.sf.data4          = lin_pdu_protocol_request.sf.data4;    // SN_byte_X_2
                lin_pdu_protocol_response.sf.data5          = lin_pdu_protocol_request.sf.data5;    // SN_byte_X_3
            }
        }                   
        break;
        
        case LOCAL_WRITE_FULL_BRIDGE_MODE:
        {
            if (FULL_BRIDGE_mode_set((t_FULL_B_MODE_en)lin_pdu_protocol_request.sf.data2) != Ok)
                lin_pdu_protocol_negative_response(lin_pdu_node_address, ERROR_CODE_REQUEST_OUT_OF_RANGE);
            else
            {
                lin_pdu_protocol_response.node_address      = lin_pdu_node_address;
                lin_pdu_protocol_response.pci_length        = 0x03;
                lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
                lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
                lin_pdu_protocol_response.sf.data2          = lin_pdu_protocol_request.sf.data2;
            }
        }
        break;

        case LOCAL_WRITE_FULL_BRIDGE_DUTY:
        {
            u16_temp = (uint16_t)(0UL | ((uint16_t)lin_pdu_protocol_request.sf.data3 << 8) | (uint16_t)lin_pdu_protocol_request.sf.data2);

            if (FULL_BRIDGE_change_duty(u16_temp) != Ok)
                lin_pdu_protocol_negative_response(lin_pdu_node_address, ERROR_CODE_REQUEST_OUT_OF_RANGE);
            else 
            {
                EE_update_param(EE_PARAM_FULL_BRIDGE_DUTY, (uint32_t)pwm_full_bridge.duty_cycle);
                FULL_BRIDGE_PARAM_set_request_to_store(FULL_BRIDGE_PARAM__DUTY_CYCLE); // salvataggio in memoria non volatile non appena igniter (full-bridge) passa da ON a OFF -> IGNITER_task_when_off

                lin_pdu_protocol_response.node_address      = lin_pdu_node_address;
                lin_pdu_protocol_response.pci_length        = 0x04;
                lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
                lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
                lin_pdu_protocol_response.sf.data2          = lin_pdu_protocol_request.sf.data2;
                lin_pdu_protocol_response.sf.data3          = lin_pdu_protocol_request.sf.data3;
            }
        }
        break;

        case LOCAL_WRITE_FULL_BRIDGE_FREQ:
        {
            u32_temp = (uint32_t)(0UL | 
                                ((uint32_t)lin_pdu_protocol_request.sf.data5 << 24) | 
                                ((uint32_t)lin_pdu_protocol_request.sf.data4 << 16) |
                                ((uint32_t)lin_pdu_protocol_request.sf.data3 <<  8) | 
                                 (uint32_t)lin_pdu_protocol_request.sf.data2);

            // Verificare che non stia funzionando con il current loop attivo, non posso modificare la frequenza 
            // istantaneamente se ho il loop di controllo attivo
            if (igniter.trigger_source != IGN_TRIG_SOURCE_NONE)
            {
                // nel caso in cui ci sai il current loop attivo rispondo in maniera positiva per agevolare ATS
                lin_pdu_protocol_response.node_address      = lin_pdu_node_address;
                lin_pdu_protocol_response.pci_length        = 0x06;
                lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
                lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
                lin_pdu_protocol_response.sf.data2          = lin_pdu_protocol_request.sf.data2;
                lin_pdu_protocol_response.sf.data3          = lin_pdu_protocol_request.sf.data3;
                lin_pdu_protocol_response.sf.data4          = lin_pdu_protocol_request.sf.data4;
                lin_pdu_protocol_response.sf.data5          = lin_pdu_protocol_request.sf.data5;   
            }
            else
            {
                if (FULL_BRIDGE_change_frequency(u32_temp) != Ok)
                    lin_pdu_protocol_negative_response(lin_pdu_node_address, ERROR_CODE_REQUEST_OUT_OF_RANGE);
                else
                {
                    FULL_BRIDGE_clear_variable();
                    
                    lin_pdu_protocol_response.node_address      = lin_pdu_node_address;
                    lin_pdu_protocol_response.pci_length        = 0x06;
                    lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
                    lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
                    lin_pdu_protocol_response.sf.data2          = lin_pdu_protocol_request.sf.data2;
                    lin_pdu_protocol_response.sf.data3          = lin_pdu_protocol_request.sf.data3;
                    lin_pdu_protocol_response.sf.data4          = lin_pdu_protocol_request.sf.data4;
                    lin_pdu_protocol_response.sf.data5          = lin_pdu_protocol_request.sf.data5;            
                }
            }
        }
        break;

        case LOCAL_WRITE_IGNITER_CONTROL_LOOP_SPEED:
        {
            if (    (lin_pdu_protocol_request.sf.data2 < IGN_CONTROL_LOOP_SPEED_N_CYCLES_MIN)
                 || (lin_pdu_protocol_request.sf.data2 > IGN_CONTROL_LOOP_SPEED_N_CYCLES_MAX)
               )
                lin_pdu_protocol_negative_response(lin_pdu_node_address, ERROR_CODE_REQUEST_OUT_OF_RANGE);
            else
            {
                EE_update_param(EE_PARAM_IGN_CONROL_LOOP_SPEED, (uint32_t)lin_pdu_protocol_request.sf.data2);
                IGN_PARAM_set_request_to_store(IGNITER_PARAM__CONTROL_LOOP_SPEED);  // salvataggio in memoria non volatile non appena igniter (full-bridge) passa da ON a OFF -> IGNITER_task_when_off

                lin_pdu_protocol_response.node_address      = lin_pdu_node_address;
                lin_pdu_protocol_response.pci_length        = 0x03;
                lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
                lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
                lin_pdu_protocol_response.sf.data2          = lin_pdu_protocol_request.sf.data2;
            }
        }
        break;

        case LOCAL_WRITE_IGNITER_1ST_RESONANT_FREQ:
        {
            u32_temp = (uint32_t)(0UL | 
                                ((uint32_t)lin_pdu_protocol_request.sf.data5 << 24) | 
                                ((uint32_t)lin_pdu_protocol_request.sf.data4 << 16) |
                                ((uint32_t)lin_pdu_protocol_request.sf.data3 <<  8) | 
                                 (uint32_t)lin_pdu_protocol_request.sf.data2);

            // Devo assicurarmi che la freq di risonanza richiesta sia compresa nel range di ricerca impostato
            if (    (    (u32_temp < EE_RAM.param.ign_resonant_frequency_start__Hz)
                      || (u32_temp > IGN_RESONANT_FREQ_START_MAX__Hz)
                    )
                 && (u32_temp != IGN_1ST_RESONANT_FREQ_UNDEFINED__Hz)
               )
                lin_pdu_protocol_negative_response(lin_pdu_node_address, ERROR_CODE_REQUEST_OUT_OF_RANGE);
            else
            {
                // NOTA: non faccio l'update in EE_RAM qui perche' non voglio cambiare is_1st_resonant_frequency_found() che usa il parametro in EE_RAM
                ign_1st_resonant_freq__Hz_to_store_new = (uint32_t)u32_temp;
                IGN_PARAM_set_request_to_store(IGNITER_PARAM__1ST_RESONANT_FREQ);   // salvataggio in memoria non volatile non appena igniter (full-bridge) passa da ON a OFF -> IGNITER_task_when_off

                lin_pdu_protocol_response.node_address      = lin_pdu_node_address;
                lin_pdu_protocol_response.pci_length        = 0x06;
                lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
                lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
                lin_pdu_protocol_response.sf.data2          = lin_pdu_protocol_request.sf.data2;
                lin_pdu_protocol_response.sf.data3          = lin_pdu_protocol_request.sf.data3;
                lin_pdu_protocol_response.sf.data4          = lin_pdu_protocol_request.sf.data4;
                lin_pdu_protocol_response.sf.data5          = lin_pdu_protocol_request.sf.data5;
            }
        }
        break;

        case LOCAL_WRITE_IGNITER_CURRENT_MIN_THRESHOLD:
        {
            u16_temp = (uint16_t)(0UL | ((uint16_t)lin_pdu_protocol_request.sf.data3 << 8) | (uint16_t)lin_pdu_protocol_request.sf.data2);

            if (    (u16_temp < IGN_RES_CURRENT_MIN_THRESHOLD_MIN)
                 || (u16_temp > IGN_RES_CURRENT_MIN_THRESHOLD_MAX)
               )
                lin_pdu_protocol_negative_response(lin_pdu_node_address, ERROR_CODE_REQUEST_OUT_OF_RANGE);
            else
            {
                EE_update_param(EE_PARAM_IGN_CURRENT_MIN_THRES, (uint32_t)u16_temp);
                IGN_PARAM_set_request_to_store(IGNITER_PARAM__RESONANT_CURRENT_MIN_THRESHOLD);  // salvataggio in memoria non volatile non appena igniter (full-bridge) passa da ON a OFF -> IGNITER_task_when_off

                lin_pdu_protocol_response.node_address      = lin_pdu_node_address;
                lin_pdu_protocol_response.pci_length        = 0x04;
                lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
                lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
                lin_pdu_protocol_response.sf.data2          = lin_pdu_protocol_request.sf.data2;
                lin_pdu_protocol_response.sf.data3          = lin_pdu_protocol_request.sf.data3;
            }
        }
        break;

        case LOCAL_WRITE_IGNITER_FREQ_STEP_LARGE:
        {
            u16_temp = (uint16_t)(0UL | ((uint16_t)lin_pdu_protocol_request.sf.data3 << 8) | (uint16_t)lin_pdu_protocol_request.sf.data2);

//            if (    (u16_temp < IGN_FREQ_STEP_LARGE_MIN__Hz)
//                 || (u16_temp > IGN_FREQ_STEP_LARGE_MAX__Hz)
//               )
//                lin_pdu_protocol_negative_response(lin_pdu_node_address, ERROR_CODE_REQUEST_OUT_OF_RANGE);
//            else
            //{
                EE_update_param(EE_PARAM_IGN_STEP_FREQ_LARGE, (uint32_t)u16_temp);
                IGN_PARAM_set_request_to_store(IGNITER_PARAM__FREQ_STEP_LARGE); // salvataggio in memoria non volatile non appena igniter (full-bridge) passa da ON a OFF -> IGNITER_task_when_off

                lin_pdu_protocol_response.node_address      = lin_pdu_node_address;
                lin_pdu_protocol_response.pci_length        = 0x04;
                lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
                lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
                lin_pdu_protocol_response.sf.data2          = lin_pdu_protocol_request.sf.data2;
                lin_pdu_protocol_response.sf.data3          = lin_pdu_protocol_request.sf.data3;
           // }
        }
        break;

        case LOCAL_WRITE_IGNITER_FREQ_STEP_MICRO:
        {
            u16_temp = (uint16_t)(0UL | ((uint16_t)lin_pdu_protocol_request.sf.data3 << 8) | (uint16_t)lin_pdu_protocol_request.sf.data2);

//            if (    (u16_temp < IGN_FREQ_STEP_MICRO_MIN__Hz)
//                 || (u16_temp > IGN_FREQ_STEP_MICRO_MAX__Hz)
//               )
//                lin_pdu_protocol_negative_response(lin_pdu_node_address, ERROR_CODE_REQUEST_OUT_OF_RANGE);
//            else
//            {
                EE_update_param(EE_PARAM_IGN_STEP_FREQ_MICRO, (uint32_t)u16_temp);
                IGN_PARAM_set_request_to_store(IGNITER_PARAM__FREQ_STEP_MICRO); // salvataggio in memoria non volatile non appena igniter (full-bridge) passa da ON a OFF -> IGNITER_task_when_off

                lin_pdu_protocol_response.node_address      = lin_pdu_node_address;
                lin_pdu_protocol_response.pci_length        = 0x04;
                lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
                lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
                lin_pdu_protocol_response.sf.data2          = lin_pdu_protocol_request.sf.data2;
                lin_pdu_protocol_response.sf.data3          = lin_pdu_protocol_request.sf.data3;
           // }
        }
        break;

        case LOCAL_WRITE_IGNITER_TRIGGER_SOURCE:
        {
            if (IGNITER_trigger_source_set(lin_pdu_protocol_request.sf.data2) != Ok)
                lin_pdu_protocol_negative_response(lin_pdu_node_address, ERROR_CODE_REQUEST_OUT_OF_RANGE);
            else
            {
                lin_pdu_protocol_response.node_address      = lin_pdu_node_address;
                lin_pdu_protocol_response.pci_length        = 0x03;
                lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
                lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
                lin_pdu_protocol_response.sf.data2          = lin_pdu_protocol_request.sf.data2;
            }
        }
        break;

        case LOCAL_WRITE_IGNITER_CONTROL_LOOP_PERIOD:
        {
            u16_temp = (uint16_t)(0UL | ((uint16_t)lin_pdu_protocol_request.sf.data3 << 8) | (uint16_t)lin_pdu_protocol_request.sf.data2);

            if (    (u16_temp < IGN_CONTROL_LOOP_PERIOD_MIN)
                 || (u16_temp > IGN_CONTROL_LOOP_PERIOD_MAX)
               )
                lin_pdu_protocol_negative_response(lin_pdu_node_address, ERROR_CODE_REQUEST_OUT_OF_RANGE);
            else
            {
                EE_update_param(EE_PARAM_IGN_CONTROL_LOOP_PERIOD, (uint32_t)u16_temp);
                IGN_PARAM_set_request_to_store(IGNITER_PARAM__CONTROL_LOOP_PERIOD);  // salvataggio in memoria non volatile non appena igniter (full-bridge) passa da ON a OFF -> IGNITER_task_when_off

                lin_pdu_protocol_response.node_address      = lin_pdu_node_address;
                lin_pdu_protocol_response.pci_length        = 0x04;
                lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
                lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
                lin_pdu_protocol_response.sf.data2          = lin_pdu_protocol_request.sf.data2;
                lin_pdu_protocol_response.sf.data3          = lin_pdu_protocol_request.sf.data3;
            }         
        }
        break;

        case LOCAL_WRITE_IGNITER_RESONANT_FREQ_START:
        {
            u32_temp = (uint32_t)(0UL | 
                                ((uint32_t)lin_pdu_protocol_request.sf.data5 << 24) | 
                                ((uint32_t)lin_pdu_protocol_request.sf.data4 << 16) |
                                ((uint32_t)lin_pdu_protocol_request.sf.data3 <<  8) | 
                                 (uint32_t)lin_pdu_protocol_request.sf.data2);

            if (    (u32_temp < IGN_RESONANT_FREQ_START_MIN__Hz)
                 || (u32_temp > IGN_RESONANT_FREQ_START_MAX__Hz)
               )
                lin_pdu_protocol_negative_response(lin_pdu_node_address, ERROR_CODE_REQUEST_OUT_OF_RANGE);
            else
            {
                // Quando modifico la frequenza minima da cui iniziare la ricerca della risonanza, devo anche ripulire la prequenza di risonanza
                // eventualmente già trovata; di cosneguenza aggiorno anche il parametro EE_RAM.param.ign_1st_resonant_freq__Hz
                EE_update_param(EE_PARAM_IGN_RESONANT_FREQ_START, (uint32_t)u32_temp);
                IGN_PARAM_set_request_to_store(IGNITER_PARAM__RESONANT_FREQUENCY_START);  // salvataggio in memoria non volatile non appena igniter (full-bridge) passa da ON a OFF -> IGNITER_task_when_off

                // richiesta di aggiornamento del paramtro EE_RAM.param.ign_1st_resonant_freq__Hz
                // NOTA: non faccio l'update in EE_RAM qui perche' non voglio cambiare is_1st_resonant_frequency_found() che usa il parametro in EE_RAM
                ign_1st_resonant_freq__Hz_to_store_new = IGN_1ST_RESONANT_FREQ_UNDEFINED__Hz;
                IGN_PARAM_set_request_to_store(IGNITER_PARAM__1ST_RESONANT_FREQ);   // salvataggio in memoria non volatile non appena igniter (full-bridge) passa da ON a OFF -> IGNITER_task_when_off

                lin_pdu_protocol_response.node_address      = lin_pdu_node_address;
                lin_pdu_protocol_response.pci_length        = 0x06;
                lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
                lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
                lin_pdu_protocol_response.sf.data2          = lin_pdu_protocol_request.sf.data2;
                lin_pdu_protocol_response.sf.data3          = lin_pdu_protocol_request.sf.data3;
                lin_pdu_protocol_response.sf.data4          = lin_pdu_protocol_request.sf.data4;
                lin_pdu_protocol_response.sf.data5          = lin_pdu_protocol_request.sf.data5;
            }
        }
        break;

        case LOCAL_WRITE_IGNITER_WAIT_CONTROL_LOOP:
        {
            if (    (lin_pdu_protocol_request.sf.data2 < IGN_CONTROL_WAITING_PERIOD_MIN)
                 || (lin_pdu_protocol_request.sf.data2 > IGN_CONTROL_WAITING_PERIOD_MAX)
               )
                lin_pdu_protocol_negative_response(lin_pdu_node_address, ERROR_CODE_REQUEST_OUT_OF_RANGE);
            else
            {
                EE_update_param(EE_PARAM_IGN_WAIT_CONTROL_LOOP, (uint32_t)lin_pdu_protocol_request.sf.data2);
                IGN_PARAM_set_request_to_store(IGNITER_PARAM__WAIT_CONTROL_LOOP);  // salvataggio in memoria non volatile non appena igniter (full-bridge) passa da ON a OFF -> IGNITER_task_when_off

                lin_pdu_protocol_response.node_address      = lin_pdu_node_address;
                lin_pdu_protocol_response.pci_length        = 0x03;
                lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
                lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
                lin_pdu_protocol_response.sf.data2          = lin_pdu_protocol_request.sf.data2;
            }        
        }
        break;

        default:
        {
            // sotto-servizio non supportato
            lin_pdu_protocol_negative_response(lin_pdu_node_address, ERROR_CODE_LOCAL_IDENTIFIER_NOT_SUPPORTED);
        }
        break;
    }
#endif
}

#ifdef EGICON
void lin_pdu_protocol_cfg__assignNAD(uint8_t node_address_for_response)
{
    // Check del SUPPLIER_ID
    if ( (lin_pdu_protocol_request.sf.data1_local_id == (SUPPLIER_ID & 0xFF)) &&    // LSB
         (lin_pdu_protocol_request.sf.data2 == ((SUPPLIER_ID >> 8) & 0xFF))         // MSB
        )
    {
        // Check del FUNCTION_ID
        if ( (lin_pdu_protocol_request.sf.data3 == (FUNCTION_ID & 0xFF)) &&         // LSB
             (lin_pdu_protocol_request.sf.data4 == ((FUNCTION_ID >> 8) & 0xFF))     // MSB
            )
        {
            // Check del NEW_NAD
            if ( (lin_pdu_protocol_request.sf.data5 < NODE_ADDRESS__MIN_VALUE) ||
                 (lin_pdu_protocol_request.sf.data5 > NODE_ADDRESS__MAX_VALUE)
                )
            {
                // Out of range
                lin_pdu_protocol_negative_response(node_address_for_response, ERROR_CODE_REQUEST_OUT_OF_RANGE);
            }
            else
            {
                EE_update_param(EE_PARAM_NAD, lin_pdu_protocol_request.sf.data5);
                LIN_PARAM_set_request_to_store(LIN_PARAM__NAD)  // salvataggio in memoria non volatile sfruttando la scrittura in eeprom degli altri parametri
                // il nuovo indirizzo viene salvato nella variabile lin_pdu_node_address quando eseguo il salvataggio in eeprom -> funzione IGNITER_task_when_off        
                
                lin_pdu_protocol_response.node_address      = node_address_for_response;
                lin_pdu_protocol_response.pci_length        = 0x01;
                lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
            }
        }
        else
        {
            // FUNCTION_ID errato
            lin_pdu_protocol_negative_response(node_address_for_response, ERROR_CODE_FUNCTION_ID_MISMATCH);
        }
    }
    else
    {
        // SUPPLIER_ID errato
        lin_pdu_protocol_negative_response(node_address_for_response, ERROR_CODE_SUPPLIER_ID_MISMATCH);
    }
}


void lin_pdu_protocol_cfg__readByIdentifier(uint8_t node_address_for_response)
{
    switch(lin_pdu_protocol_request.sf.data1_local_id)
    {
        case READ_BY_IDENTIFIER__NAD_EEP:
        {
            lin_pdu_protocol_response.node_address      = node_address_for_response;
            lin_pdu_protocol_response.pci_length        = 0x03;
            lin_pdu_protocol_response.sf.service_id     = Service_ID_response(lin_pdu_protocol_request.sf.service_id);
            lin_pdu_protocol_response.sf.data1_local_id = lin_pdu_protocol_request.sf.data1_local_id;
            lin_pdu_protocol_response.sf.data2          = EE_RAM.param.lf_lin_node_address;
        }
        break;
        
        default:
        {
            // sotto-servizio non supportato
            lin_pdu_protocol_negative_response(node_address_for_response, ERROR_CODE_LOCAL_IDENTIFIER_NOT_SUPPORTED);
        }
        break;
    }
}
#endif


/* ****************************************************************************************
 *  EOF
 * **************************************************************************************** */
